{
  "address": "0xD5dbA71698E52271438B90E1fC658cB94F637aa1",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IStrategyManager",
          "name": "_strategyManager",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "version",
          "type": "uint8"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "previousValue",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newValue",
          "type": "uint256"
        }
      ],
      "name": "MaxPerDepositUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "previousValue",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newValue",
          "type": "uint256"
        }
      ],
      "name": "MaxTotalDepositsUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newPausedStatus",
          "type": "uint256"
        }
      ],
      "name": "Paused",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "contract IPauserRegistry",
          "name": "pauserRegistry",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "contract IPauserRegistry",
          "name": "newPauserRegistry",
          "type": "address"
        }
      ],
      "name": "PauserRegistrySet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newPausedStatus",
          "type": "uint256"
        }
      ],
      "name": "Unpaused",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "deposit",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "newShares",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "explanation",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getTVLLimits",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_maxPerDeposit",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_maxTotalDeposits",
          "type": "uint256"
        },
        {
          "internalType": "contract IERC20",
          "name": "_underlyingToken",
          "type": "address"
        },
        {
          "internalType": "contract IPauserRegistry",
          "name": "_pauserRegistry",
          "type": "address"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC20",
          "name": "_underlyingToken",
          "type": "address"
        },
        {
          "internalType": "contract IPauserRegistry",
          "name": "_pauserRegistry",
          "type": "address"
        }
      ],
      "name": "initializeBase",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "maxPerDeposit",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "maxTotalDeposits",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "newPausedStatus",
          "type": "uint256"
        }
      ],
      "name": "pause",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pauseAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "index",
          "type": "uint8"
        }
      ],
      "name": "paused",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "paused",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pauserRegistry",
      "outputs": [
        {
          "internalType": "contract IPauserRegistry",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IPauserRegistry",
          "name": "newPauserRegistry",
          "type": "address"
        }
      ],
      "name": "setPauserRegistry",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "newMaxPerDeposit",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "newMaxTotalDeposits",
          "type": "uint256"
        }
      ],
      "name": "setTVLLimits",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "shares",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountShares",
          "type": "uint256"
        }
      ],
      "name": "sharesToUnderlying",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountShares",
          "type": "uint256"
        }
      ],
      "name": "sharesToUnderlyingView",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "strategyManager",
      "outputs": [
        {
          "internalType": "contract IStrategyManager",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalShares",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountUnderlying",
          "type": "uint256"
        }
      ],
      "name": "underlyingToShares",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountUnderlying",
          "type": "uint256"
        }
      ],
      "name": "underlyingToSharesView",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "underlyingToken",
      "outputs": [
        {
          "internalType": "contract IERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "newPausedStatus",
          "type": "uint256"
        }
      ],
      "name": "unpause",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "userUnderlying",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "userUnderlyingView",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amountShares",
          "type": "uint256"
        }
      ],
      "name": "withdraw",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x40e9ba4e6ff6d72dadc4cdc5f7cc599883abee791866dfbf1d3f8d23bbca8cb4",
  "receipt": {
    "to": null,
    "from": "0x1Ee532cf775be02E0B306571e3555321FC75988d",
    "contractAddress": "0xD5dbA71698E52271438B90E1fC658cB94F637aa1",
    "transactionIndex": 0,
    "gasUsed": "1737356",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000",
    "blockHash": "0x9b323a8be5f68ae922bf9a1431fffcab6c9f4a750ab9e80d917ff259b81f5ab1",
    "transactionHash": "0x40e9ba4e6ff6d72dadc4cdc5f7cc599883abee791866dfbf1d3f8d23bbca8cb4",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 40803876,
        "transactionHash": "0x40e9ba4e6ff6d72dadc4cdc5f7cc599883abee791866dfbf1d3f8d23bbca8cb4",
        "address": "0xD5dbA71698E52271438B90E1fC658cB94F637aa1",
        "topics": [
          "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000000000000000ff",
        "logIndex": 0,
        "blockHash": "0x9b323a8be5f68ae922bf9a1431fffcab6c9f4a750ab9e80d917ff259b81f5ab1"
      }
    ],
    "blockNumber": 40803876,
    "cumulativeGasUsed": "1737356",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xd914b20BcFcdBb396697a957fc28a77947593bE5"
  ],
  "numDeployments": 1,
  "solcInputHash": "73a843c7df9a0737c5f562139718a87a",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IStrategyManager\",\"name\":\"_strategyManager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"MaxPerDepositUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"MaxTotalDepositsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPausedStatus\",\"type\":\"uint256\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IPauserRegistry\",\"name\":\"pauserRegistry\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IPauserRegistry\",\"name\":\"newPauserRegistry\",\"type\":\"address\"}],\"name\":\"PauserRegistrySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPausedStatus\",\"type\":\"uint256\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newShares\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"explanation\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTVLLimits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxPerDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxTotalDeposits\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"_underlyingToken\",\"type\":\"address\"},{\"internalType\":\"contract IPauserRegistry\",\"name\":\"_pauserRegistry\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_underlyingToken\",\"type\":\"address\"},{\"internalType\":\"contract IPauserRegistry\",\"name\":\"_pauserRegistry\",\"type\":\"address\"}],\"name\":\"initializeBase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPerDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTotalDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPausedStatus\",\"type\":\"uint256\"}],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauserRegistry\",\"outputs\":[{\"internalType\":\"contract IPauserRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPauserRegistry\",\"name\":\"newPauserRegistry\",\"type\":\"address\"}],\"name\":\"setPauserRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxPerDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMaxTotalDeposits\",\"type\":\"uint256\"}],\"name\":\"setTVLLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"shares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountShares\",\"type\":\"uint256\"}],\"name\":\"sharesToUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountShares\",\"type\":\"uint256\"}],\"name\":\"sharesToUnderlyingView\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategyManager\",\"outputs\":[{\"internalType\":\"contract IStrategyManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountUnderlying\",\"type\":\"uint256\"}],\"name\":\"underlyingToShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountUnderlying\",\"type\":\"uint256\"}],\"name\":\"underlyingToSharesView\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPausedStatus\",\"type\":\"uint256\"}],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userUnderlyingView\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountShares\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Note that this implementation still converts between any amount of shares or underlying tokens in its view functions; these functions purposefully do not take the TVL limit into account.\",\"events\":{\"Initialized(uint8)\":{\"details\":\"Triggered when the contract has been initialized or reinitialized.\"}},\"kind\":\"dev\",\"methods\":{\"constructor\":{\"custom:oz-upgrades-unsafe-allow\":\"constructor\"},\"deposit(address,uint256)\":{\"details\":\"This function is only callable by the strategyManager contract. It is invoked inside of the strategyManager's `depositIntoStrategy` function, and individual share balances are recorded in the strategyManager as well.Note that the assumption is made that `amount` of `token` has already been transferred directly to this contract (as performed in the StrategyManager's deposit functions). In particular, setting the `underlyingToken` of this contract to be a fee-on-transfer token will break the assumption that the amount this contract *received* of the token is equal to the amount that was input when the transfer was performed (i.e. the amount transferred 'out' of the depositor's balance).Note that any validation of `token` is done inside `_beforeDeposit`. This can be overridden if needed.\",\"params\":{\"amount\":\"is the amount of token being deposited\",\"token\":\"is the ERC20 token being deposited\"},\"returns\":{\"newShares\":\"is the number of new shares issued at the current exchange ratio.\"}},\"pause(uint256)\":{\"details\":\"This function can only pause functionality, and thus cannot 'unflip' any bit in `_paused` from 1 to 0.\",\"params\":{\"newPausedStatus\":\"represents the new value for `_paused` to take, which means it may flip several bits at once.\"}},\"setTVLLimits(uint256,uint256)\":{\"details\":\"Callable only by the unpauser of this contractWe note that there is a potential race condition between a call to this function that lowers either or both of these limits and call(s) to `deposit`, that may result in some calls to `deposit` reverting.\",\"params\":{\"newMaxTotalDeposits\":\"The new maximum deposits\"}},\"sharesToUnderlying(uint256)\":{\"details\":\"Implementation for these functions in particular may vary significantly for different strategies\",\"params\":{\"amountShares\":\"is the amount of shares to calculate its conversion into the underlying token\"},\"returns\":{\"_0\":\"The amount of underlying tokens corresponding to the input `amountShares`\"}},\"sharesToUnderlyingView(uint256)\":{\"details\":\"Implementation for these functions in particular may vary significantly for different strategies\",\"params\":{\"amountShares\":\"is the amount of shares to calculate its conversion into the underlying token\"},\"returns\":{\"_0\":\"The amount of underlying tokens corresponding to the input `amountShares`\"}},\"underlyingToShares(uint256)\":{\"details\":\"Implementation for these functions in particular may vary significantly for different strategies\",\"params\":{\"amountUnderlying\":\"is the amount of `underlyingToken` to calculate its conversion into strategy shares\"},\"returns\":{\"_0\":\"The amount of shares corresponding to the input `amountUnderlying`\"}},\"underlyingToSharesView(uint256)\":{\"details\":\"Implementation for these functions in particular may vary significantly for different strategies\",\"params\":{\"amountUnderlying\":\"is the amount of `underlyingToken` to calculate its conversion into strategy shares\"},\"returns\":{\"_0\":\"The amount of shares corresponding to the input `amountUnderlying`\"}},\"unpause(uint256)\":{\"details\":\"This function can only unpause functionality, and thus cannot 'flip' any bit in `_paused` from 0 to 1.\",\"params\":{\"newPausedStatus\":\"represents the new value for `_paused` to take, which means it may flip several bits at once.\"}},\"withdraw(address,address,uint256)\":{\"details\":\"This function is only callable by the strategyManager contract. It is invoked inside of the strategyManager's other functions, and individual share balances are recorded in the strategyManager as well.Note that any validation of `token` is done inside `_beforeWithdrawal`. This can be overridden if needed.\",\"params\":{\"amountShares\":\"is the amount of shares being withdrawn\",\"recipient\":\"is the address to receive the withdrawn funds\",\"token\":\"is the ERC20 token being transferred out\"}}},\"stateVariables\":{\"__gap\":{\"details\":\"This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain. See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\"}},\"title\":\"A Strategy implementation inheriting from `StrategyBase` that limits the total amount of deposits it will accept.\",\"version\":1},\"userdoc\":{\"events\":{\"MaxPerDepositUpdated(uint256,uint256)\":{\"notice\":\"Emitted when `maxPerDeposit` value is updated from `previousValue` to `newValue`\"},\"MaxTotalDepositsUpdated(uint256,uint256)\":{\"notice\":\"Emitted when `maxTotalDeposits` value is updated from `previousValue` to `newValue`\"},\"Paused(address,uint256)\":{\"notice\":\"Emitted when the pause is triggered by `account`, and changed to `newPausedStatus`.\"},\"PauserRegistrySet(address,address)\":{\"notice\":\"Emitted when the `pauserRegistry` is set to `newPauserRegistry`.\"},\"Unpaused(address,uint256)\":{\"notice\":\"Emitted when the pause is lifted by `account`, and changed to `newPausedStatus`.\"}},\"kind\":\"user\",\"methods\":{\"constructor\":{\"notice\":\"solhint-disable-next-line no-empty-blocks\"},\"deposit(address,uint256)\":{\"notice\":\"Used to deposit tokens into this Strategy\"},\"explanation()\":{\"notice\":\"Currently returns a brief string explaining the strategy's goal & purpose, but for more complex strategies, may be a link to metadata that explains in more detail.\"},\"getTVLLimits()\":{\"notice\":\"Simple getter function that returns the current values of `maxPerDeposit` and `maxTotalDeposits`.\"},\"maxPerDeposit()\":{\"notice\":\"The maximum deposit (in underlyingToken) that this strategy will accept per deposit\"},\"maxTotalDeposits()\":{\"notice\":\"The maximum deposits (in underlyingToken) that this strategy will hold\"},\"pause(uint256)\":{\"notice\":\"This function is used to pause an BinLayer contract's functionality. It is permissioned to the `pauser` address, which is expected to be a low threshold multisig.\"},\"pauseAll()\":{\"notice\":\"Alias for `pause(type(uint256).max)`.\"},\"paused()\":{\"notice\":\"Returns the current paused status as a uint256.\"},\"paused(uint8)\":{\"notice\":\"Returns 'true' if the `indexed`th bit of `_paused` is 1, and 'false' otherwise\"},\"pauserRegistry()\":{\"notice\":\"Address of the `PauserRegistry` contract that this contract defers to for determining access control (for pausing).\"},\"setPauserRegistry(address)\":{\"notice\":\"Allows the unpauser to set a new pauser registry\"},\"setTVLLimits(uint256,uint256)\":{\"notice\":\"Sets the maximum deposits (in underlyingToken) that this strategy will hold and accept per deposit\"},\"shares(address)\":{\"notice\":\"convenience function for fetching the current total shares of `user` in this strategy, by querying the `strategyManager` contract\"},\"sharesToUnderlying(uint256)\":{\"notice\":\"Used to convert a number of shares to the equivalent amount of underlying tokens for this strategy.In contrast to `sharesToUnderlyingView`, this function **may** make state modifications\"},\"sharesToUnderlyingView(uint256)\":{\"notice\":\"Used to convert a number of shares to the equivalent amount of underlying tokens for this strategy.In contrast to `sharesToUnderlying`, this function guarantees no state modifications\"},\"strategyManager()\":{\"notice\":\"BinLayer's StrategyManager contract\"},\"totalShares()\":{\"notice\":\"The total number of extant shares in this Strategy\"},\"underlyingToShares(uint256)\":{\"notice\":\"Used to convert an amount of underlying tokens to the equivalent amount of shares in this strategy.In contrast to `underlyingToSharesView`, this function **may** make state modifications\"},\"underlyingToSharesView(uint256)\":{\"notice\":\"Used to convert an amount of underlying tokens to the equivalent amount of shares in this strategy.In contrast to `underlyingToShares`, this function guarantees no state modifications\"},\"underlyingToken()\":{\"notice\":\"The underlying token for shares in this Strategy\"},\"unpause(uint256)\":{\"notice\":\"This function is used to unpause an BinLayer contract's functionality. It is permissioned to the `unpauser` address, which is expected to be a high threshold multisig or governance contract.\"},\"userUnderlying(address)\":{\"notice\":\"convenience function for fetching the current underlying value of all of the `user`'s shares in this strategy. In contrast to `userUnderlyingView`, this function **may** make state modifications\"},\"userUnderlyingView(address)\":{\"notice\":\"convenience function for fetching the current underlying value of all of the `user`'s shares in this strategy. In contrast to `userUnderlying`, this function guarantees no state modifications\"},\"withdraw(address,address,uint256)\":{\"notice\":\"Used to withdraw tokens from this Strategy, to the `recipient`'s address\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/strategies/StrategyBaseTVLLimits.sol\":\"StrategyBaseTVLLimits\"},\"evmVersion\":\"berlin\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1500},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0x89be10e757d242e9b18d5a32c9fbe2019f6d63052bbe46397a430a1d60d7f794\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9c80f545915582e63fe206c6ce27cbe85a86fc10b9cd2a0e8c9488fb7c2ee422\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xb264c03a3442eb37a68ad620cefd1182766b58bee6cec40343480392d6b14d69\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0xabefac93435967b4d36a4fabcbdbb918d1f0b7ae3c3d85bc30923b326c927ed1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"contracts/interfaces/IDelegationManager.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0\\npragma solidity 0.8.20;\\n\\nimport './IStrategy.sol';\\nimport './ISignatureUtils.sol';\\nimport './IStrategyManager.sol';\\n\\n/**\\n * @title DelegationManager\\n * @notice  This is the contract for delegation in BinLayer. The main functionalities of this contract are\\n * - enabling anyone to register as an operator in BinLayer\\n * - allowing operators to specify parameters related to stakers who delegate to them\\n * - enabling any staker to delegate its stake to the operator of its choice (a given staker can only delegate to a single operator at a time)\\n * - enabling a staker to undelegate its assets from the operator it is delegated to (performed as part of the withdrawal process, initiated through the StrategyManager)\\n */\\ninterface IDelegationManager is ISignatureUtils {\\n  // @notice Struct used for storing information about a single operator who has registered with BinLayer\\n  struct OperatorDetails {\\n    // @notice address to receive the rewards that the operator earns via serving applications built on BinLayer.\\n    address earningsReceiver;\\n    /**\\n     * @notice Address to verify signatures when a staker wishes to delegate to the operator, as well as controlling \\\"forced undelegations\\\".\\n     * @dev Signature verification follows these rules:\\n     * 1) If this address is left as address(0), then any staker will be free to delegate to the operator, i.e. no signature verification will be performed.\\n     * 2) If this address is an EOA (i.e. it has no code), then we follow standard ECDSA signature verification for delegations to the operator.\\n     * 3) If this address is a contract (i.e. it has code) then we forward a call to the contract and verify that it returns the correct EIP-1271 \\\"magic value\\\".\\n     */\\n    address delegationApprover;\\n    /**\\n     * @notice A minimum delay -- enforced between:\\n     * 1) the operator signalling their intent to register for a service, via calling `Slasher.optIntoSlashing`\\n     * and\\n     * 2) the operator completing registration for the service, via the service ultimately calling `Slasher.recordFirstStakeUpdate`\\n     * @dev note that for a specific operator, this value *cannot decrease*, i.e. if the operator wishes to modify their OperatorDetails,\\n     * then they are only allowed to either increase this value or keep it the same.\\n     */\\n    uint32 stakerOptOutWindow;\\n  }\\n\\n  /**\\n   * @notice Abstract struct used in calculating an EIP712 signature for a staker to approve that they (the staker themselves) delegate to a specific operator.\\n   * @dev Used in computing the `STAKER_DELEGATION_TYPEHASH` and as a reference in the computation of the stakerDigestHash in the `delegateToBySignature` function.\\n   */\\n  struct StakerDelegation {\\n    // the staker who is delegating\\n    address staker;\\n    // the operator being delegated to\\n    address operator;\\n    // the staker's nonce\\n    uint256 nonce;\\n    // the expiration timestamp (UTC) of the signature\\n    uint256 expiry;\\n  }\\n\\n  /**\\n   * @notice Abstract struct used in calculating an EIP712 signature for an operator's delegationApprover to approve that a specific staker delegate to the operator.\\n   * @dev Used in computing the `DELEGATION_APPROVAL_TYPEHASH` and as a reference in the computation of the approverDigestHash in the `_delegate` function.\\n   */\\n  struct DelegationApproval {\\n    // the staker who is delegating\\n    address staker;\\n    // the operator being delegated to\\n    address operator;\\n    // the operator's provided salt\\n    bytes32 salt;\\n    // the expiration timestamp (UTC) of the signature\\n    uint256 expiry;\\n  }\\n\\n  /**\\n   * Struct type used to specify an existing queued withdrawal. Rather than storing the entire struct, only a hash is stored.\\n   * In functions that operate on existing queued withdrawals -- e.g. completeQueuedWithdrawal`, the data is resubmitted and the hash of the submitted\\n   * data is computed by `calculateWithdrawalRoot` and checked against the stored hash in order to confirm the integrity of the submitted data.\\n   */\\n  struct Withdrawal {\\n    // The address that originated the Withdrawal\\n    address staker;\\n    // The address that the staker was delegated to at the time that the Withdrawal was created\\n    address delegatedTo;\\n    // The address that can complete the Withdrawal + will receive funds when completing the withdrawal\\n    address withdrawer;\\n    // Nonce used to guarantee that otherwise identical withdrawals have unique hashes\\n    uint256 nonce;\\n    // Block timestamp when the Withdrawal was created\\n    uint32 startTimestamp;\\n    // Array of strategies that the Withdrawal contains\\n    IStrategy[] strategies;\\n    // Array containing the amount of shares in each Strategy in the `strategies` array\\n    uint256[] shares;\\n  }\\n\\n  struct QueuedWithdrawalParams {\\n    // Array of strategies that the QueuedWithdrawal contains\\n    IStrategy[] strategies;\\n    // Array containing the amount of shares in each Strategy in the `strategies` array\\n    uint256[] shares;\\n    // The address of the withdrawer\\n    address withdrawer;\\n  }\\n\\n  // @notice Emitted when a new operator registers in BinLayer and provides their OperatorDetails.\\n  event OperatorRegistered(address indexed operator, OperatorDetails operatorDetails);\\n\\n  /// @notice Emitted when an operator updates their OperatorDetails to @param newOperatorDetails\\n  event OperatorDetailsModified(address indexed operator, OperatorDetails newOperatorDetails);\\n\\n  /**\\n   * @notice Emitted when @param operator indicates that they are updating their MetadataURI string\\n   * @dev Note that these strings are *never stored in storage* and are instead purely emitted in events for off-chain indexing\\n   */\\n  event OperatorMetadataURIUpdated(address indexed operator, string metadataURI);\\n\\n  /// @notice Emitted whenever an operator's shares are increased for a given strategy. Note that shares is the delta in the operator's shares.\\n  event OperatorSharesIncreased(address indexed operator, address staker, IStrategy strategy, uint256 shares);\\n\\n  /// @notice Emitted whenever an operator's shares are decreased for a given strategy. Note that shares is the delta in the operator's shares.\\n  event OperatorSharesDecreased(address indexed operator, address staker, IStrategy strategy, uint256 shares);\\n\\n  /// @notice Emitted when @param staker delegates to @param operator.\\n  event StakerDelegated(address indexed staker, address indexed operator);\\n\\n  /// @notice Emitted when @param staker undelegates from @param operator.\\n  event StakerUndelegated(address indexed staker, address indexed operator);\\n\\n  /// @notice Emitted when @param staker is undelegated via a call not originating from the staker themself\\n  event StakerForceUndelegated(address indexed staker, address indexed operator);\\n\\n  /**\\n   * @notice Emitted when a new withdrawal is queued.\\n   * @param withdrawalRoot Is the hash of the `withdrawal`.\\n   * @param withdrawal Is the withdrawal itself.\\n   */\\n  event WithdrawalQueued(bytes32 withdrawalRoot, Withdrawal withdrawal);\\n\\n  /// @notice Emitted when a queued withdrawal is completed\\n  event WithdrawalCompleted(bytes32 withdrawalRoot);\\n\\n  /// @notice Emitted when the `minWithdrawalDelay` variable is modified from `previousValue` to `newValue`.\\n  event MinWithdrawalDelaySet(uint256 previousValue, uint256 newValue);\\n\\n  /// @notice Emitted when the `strategyWithdrawalDelay` variable is modified from `previousValue` to `newValue`.\\n  event StrategyWithdrawalDelaySet(IStrategy strategy, uint256 previousValue, uint256 newValue);\\n\\n  event UpdateWrappedTokenGateway(address previousGateway, address currentGateway);\\n\\n  /**\\n   * @notice Registers the caller as an operator in BinLayer.\\n   * @param registeringOperatorDetails is the `OperatorDetails` for the operator.\\n   * @param metadataURI is a URI for the operator's metadata, i.e. a link providing more details on the operator.\\n   *\\n   * @dev Once an operator is registered, they cannot 'deregister' as an operator, and they will forever be considered \\\"delegated to themself\\\".\\n   * @dev This function will revert if the caller attempts to set their `earningsReceiver` to address(0).\\n   * @dev Note that the `metadataURI` is *never stored * and is only emitted in the `OperatorMetadataURIUpdated` event\\n   */\\n  function registerAsOperator(OperatorDetails calldata registeringOperatorDetails, string calldata metadataURI) external;\\n\\n  /**\\n   * @notice Updates an operator's stored `OperatorDetails`.\\n   * @param newOperatorDetails is the updated `OperatorDetails` for the operator, to replace their current OperatorDetails`.\\n   *\\n   * @dev The caller must have previously registered as an operator in BinLayer.\\n   * @dev This function will revert if the caller attempts to set their `earningsReceiver` to address(0).\\n   */\\n  function modifyOperatorDetails(OperatorDetails calldata newOperatorDetails) external;\\n\\n  /**\\n   * @notice Called by an operator to emit an `OperatorMetadataURIUpdated` event indicating the information has updated.\\n   * @param metadataURI The URI for metadata associated with an operator\\n   * @dev Note that the `metadataURI` is *never stored * and is only emitted in the `OperatorMetadataURIUpdated` event\\n   */\\n  function updateOperatorMetadataURI(string calldata metadataURI) external;\\n\\n  /**\\n   * @notice Caller delegates their stake to an operator.\\n   * @param operator The account (`msg.sender`) is delegating its assets to for use in serving applications built on BinLayer.\\n   * @param approverSignatureAndExpiry Verifies the operator approves of this delegation\\n   * @param approverSalt A unique single use value tied to an individual signature.\\n   * @dev The approverSignatureAndExpiry is used in the event that:\\n   *          1) the operator's `delegationApprover` address is set to a non-zero value.\\n   *                  AND\\n   *          2) neither the operator nor their `delegationApprover` is the `msg.sender`, since in the event that the operator\\n   *             or their delegationApprover is the `msg.sender`, then approval is assumed.\\n   * @dev In the event that `approverSignatureAndExpiry` is not checked, its content is ignored entirely; it's recommended to use an empty input\\n   * in this case to save on complexity + gas costs\\n   */\\n  function delegateTo(address operator, SignatureWithExpiry memory approverSignatureAndExpiry, bytes32 approverSalt) external;\\n\\n  /**\\n   * @notice Caller delegates a staker's stake to an operator with valid signatures from both parties.\\n   * @param staker The account delegating stake to an `operator` account\\n   * @param operator The account (`staker`) is delegating its assets to for use in serving applications built on BinLayer.\\n   * @param stakerSignatureAndExpiry Signed data from the staker authorizing delegating stake to an operator\\n   * @param approverSignatureAndExpiry is a parameter that will be used for verifying that the operator approves of this delegation action in the event that:\\n   * @param approverSalt Is a salt used to help guarantee signature uniqueness. Each salt can only be used once by a given approver.\\n   *\\n   * @dev If `staker` is an EOA, then `stakerSignature` is verified to be a valid ECDSA stakerSignature from `staker`, indicating their intention for this action.\\n   * @dev If `staker` is a contract, then `stakerSignature` will be checked according to EIP-1271.\\n   * @dev the operator's `delegationApprover` address is set to a non-zero value.\\n   * @dev neither the operator nor their `delegationApprover` is the `msg.sender`, since in the event that the operator or their delegationApprover\\n   * is the `msg.sender`, then approval is assumed.\\n   * @dev This function will revert if the current `block.timestamp` is equal to or exceeds the expiry\\n   * @dev In the case that `approverSignatureAndExpiry` is not checked, its content is ignored entirely; it's recommended to use an empty input\\n   * in this case to save on complexity + gas costs\\n   */\\n  function delegateToBySignature(\\n    address staker,\\n    address operator,\\n    SignatureWithExpiry memory stakerSignatureAndExpiry,\\n    SignatureWithExpiry memory approverSignatureAndExpiry,\\n    bytes32 approverSalt\\n  ) external;\\n\\n  /**\\n   * @notice Undelegates the staker from the operator who they are delegated to. Puts the staker into the \\\"undelegation limbo\\\" mode of the EigenPodManager\\n   * and queues a withdrawal of all of the staker's shares in the StrategyManager (to the staker), if necessary.\\n   * @param staker The account to be undelegated.\\n   * @return withdrawalRoot The root of the newly queued withdrawal, if a withdrawal was queued. Otherwise just bytes32(0).\\n   *\\n   * @dev Reverts if the `staker` is also an operator, since operators are not allowed to undelegate from themselves.\\n   * @dev Reverts if the caller is not the staker, nor the operator who the staker is delegated to, nor the operator's specified \\\"delegationApprover\\\"\\n   * @dev Reverts if the `staker` is already undelegated.\\n   */\\n  function undelegate(address staker) external returns (bytes32[] memory withdrawalRoot);\\n\\n  /**\\n   * Allows a staker to withdraw some shares. Withdrawn shares/strategies are immediately removed\\n   * from the staker. If the staker is delegated, withdrawn shares/strategies are also removed from\\n   * their operator.\\n   *\\n   * All withdrawn shares/strategies are placed in a queue and can be fully withdrawn after a delay.\\n   */\\n  function queueWithdrawals(QueuedWithdrawalParams[] calldata queuedWithdrawalParams) external returns (bytes32[] memory);\\n\\n  /**\\n   * @notice Used to complete the specified `withdrawal`. The caller must match `withdrawal.withdrawer`\\n   * @param withdrawal The Withdrawal to complete.\\n   * @param tokens Array in which the i-th entry specifies the `token` input to the 'withdraw' function of the i-th Strategy in the `withdrawal.strategies` array.\\n   * This input can be provided with zero length if `receiveAsTokens` is set to 'false' (since in that case, this input will be unused)\\n   * @param middlewareTimesIndex is the index in the operator that the staker who triggered the withdrawal was delegated to's middleware times array\\n   * @param receiveAsTokens If true, the shares specified in the withdrawal will be withdrawn from the specified strategies themselves\\n   * and sent to the caller, through calls to `withdrawal.strategies[i].withdraw`. If false, then the shares in the specified strategies\\n   * will simply be transferred to the caller directly.\\n   * @dev middlewareTimesIndex should be calculated off chain before calling this function by finding the first index that satisfies `slasher.canWithdraw`\\n   * @dev beaconChainETHStrategy shares are non-transferrable, so if `receiveAsTokens = false` and `withdrawal.withdrawer != withdrawal.staker`, note that\\n   * any beaconChainETHStrategy shares in the `withdrawal` will be _returned to the staker_, rather than transferred to the withdrawer, unlike shares in\\n   * any other strategies, which will be transferred to the withdrawer.\\n   */\\n  function completeQueuedWithdrawal(\\n    Withdrawal calldata withdrawal,\\n    IERC20[] calldata tokens,\\n    uint256 middlewareTimesIndex,\\n    bool receiveAsTokens\\n  ) external;\\n\\n  /**\\n   * @notice Array-ified version of `completeQueuedWithdrawal`.\\n   * Used to complete the specified `withdrawals`. The function caller must match `withdrawals[...].withdrawer`\\n   * @param withdrawals The Withdrawals to complete.\\n   * @param tokens Array of tokens for each Withdrawal. See `completeQueuedWithdrawal` for the usage of a single array.\\n   * @param middlewareTimesIndexes One index to reference per Withdrawal. See `completeQueuedWithdrawal` for the usage of a single index.\\n   * @param receiveAsTokens Whether or not to complete each withdrawal as tokens. See `completeQueuedWithdrawal` for the usage of a single boolean.\\n   * @dev See `completeQueuedWithdrawal` for relevant dev tags\\n   */\\n  function completeQueuedWithdrawals(\\n    Withdrawal[] calldata withdrawals,\\n    IERC20[][] calldata tokens,\\n    uint256[] calldata middlewareTimesIndexes,\\n    bool[] calldata receiveAsTokens\\n  ) external;\\n\\n  /**\\n   * @notice Increases a staker's delegated share balance in a strategy.\\n   * @param staker The address to increase the delegated shares for their operator.\\n   * @param strategy The strategy in which to increase the delegated shares.\\n   * @param shares The number of shares to increase.\\n   *\\n   * @dev *If the staker is actively delegated*, then increases the `staker`'s delegated shares in `strategy` by `shares`. Otherwise does nothing.\\n   * @dev Callable only by the StrategyManager or EigenPodManager.\\n   */\\n  function increaseDelegatedShares(address staker, IStrategy strategy, uint256 shares) external;\\n\\n  /**\\n   * @notice Decreases a staker's delegated share balance in a strategy.\\n   * @param staker The address to increase the delegated shares for their operator.\\n   * @param strategy The strategy in which to decrease the delegated shares.\\n   * @param shares The number of shares to decrease.\\n   *\\n   * @dev *If the staker is actively delegated*, then decreases the `staker`'s delegated shares in `strategy` by `shares`. Otherwise does nothing.\\n   * @dev Callable only by the StrategyManager or EigenPodManager.\\n   */\\n  function decreaseDelegatedShares(address staker, IStrategy strategy, uint256 shares) external;\\n\\n  /**\\n   * @notice returns the address of the operator that `staker` is delegated to.\\n   * @notice Mapping: staker => operator whom the staker is currently delegated to.\\n   * @dev Note that returning address(0) indicates that the staker is not actively delegated to any operator.\\n   */\\n  function delegatedTo(address staker) external view returns (address);\\n\\n  /**\\n   * @notice Returns the OperatorDetails struct associated with an `operator`.\\n   */\\n  function operatorDetails(address operator) external view returns (OperatorDetails memory);\\n\\n  /*\\n   * @notice Returns the earnings receiver address for an operator\\n   */\\n  function earningsReceiver(address operator) external view returns (address);\\n\\n  /**\\n   * @notice Returns the delegationApprover account for an operator\\n   */\\n  function delegationApprover(address operator) external view returns (address);\\n\\n  /**\\n   * @notice Returns the stakerOptOutWindow for an operator\\n   */\\n  function stakerOptOutWindow(address operator) external view returns (uint256);\\n\\n  /**\\n   * @notice Given array of strategies, returns array of shares for the operator\\n   */\\n  function getOperatorShares(address operator, IStrategy[] memory strategies) external view returns (uint256[] memory);\\n\\n  /**\\n   * @notice Given a list of strategies, return the minimum cooldown that must pass to withdraw\\n   * from all the inputted strategies. Return value is >= minWithdrawalDelay as this is the global min withdrawal delay.\\n   * @param strategies The strategies to check withdrawal delays for\\n   */\\n  function getWithdrawalDelay(IStrategy[] calldata strategies) external view returns (uint256);\\n\\n  /**\\n   * @notice returns the total number of shares in `strategy` that are delegated to `operator`.\\n   * @notice Mapping: operator => strategy => total number of shares in the strategy delegated to the operator.\\n   * @dev By design, the following invariant should hold for each Strategy:\\n   * (operator's shares in delegation manager) = sum (shares above zero of all stakers delegated to operator)\\n   * = sum (delegateable shares of all stakers delegated to the operator)\\n   */\\n  function operatorShares(address operator, IStrategy strategy) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns 'true' if `staker` *is* actively delegated, and 'false' otherwise.\\n   */\\n  function isDelegated(address staker) external view returns (bool);\\n\\n  /**\\n   * @notice Returns true is an operator has previously registered for delegation.\\n   */\\n  function isOperator(address operator) external view returns (bool);\\n\\n  /// @notice Mapping: staker => number of signed delegation nonces (used in `delegateToBySignature`) from the staker that the contract has already checked\\n  function stakerNonce(address staker) external view returns (uint256);\\n\\n  /**\\n   * @notice Mapping: delegationApprover => 32-byte salt => whether or not the salt has already been used by the delegationApprover.\\n   * @dev Salts are used in the `delegateTo` and `delegateToBySignature` functions. Note that these functions only process the delegationApprover's\\n   * signature + the provided salt if the operator being delegated to has specified a nonzero address as their `delegationApprover`.\\n   */\\n  function delegationApproverSaltIsSpent(address _delegationApprover, bytes32 salt) external view returns (bool);\\n\\n  /**\\n   * @notice Minimum delay enforced by this contract for completing queued withdrawals. Cooldown, and adjustable by this contract's owner,\\n   * up to a maximum of `MAX_WITHDRAWAL_DELAY`. Minimum value is 0 (i.e. no delay enforced).\\n   * Note that strategies each have a separate withdrawal delay, which can be greater than this value. So the minimum cooldown that must pass\\n   * to withdraw a strategy is MAX(minWithdrawalDelay, strategyWithdrawalDelay[strategy])\\n   */\\n  function minWithdrawalDelay() external view returns (uint256);\\n\\n  /**\\n   * @notice Minimum delay enforced by this contract per Strategy for completing queued withdrawals. Cooldown, and adjustable by this contract's owner,\\n   * up to a maximum of `MAX_WITHDRAWAL_DELAY`. Minimum value is 0 (i.e. no delay enforced).\\n   */\\n  function strategyWithdrawalDelay(IStrategy strategy) external view returns (uint256);\\n\\n  /**\\n   * @notice Calculates the digestHash for a `staker` to sign to delegate to an `operator`\\n   * @param staker The signing staker\\n   * @param operator The operator who is being delegated to\\n   * @param expiry The desired expiry time of the staker's signature\\n   */\\n  function calculateCurrentStakerDelegationDigestHash(address staker, address operator, uint256 expiry) external view returns (bytes32);\\n\\n  /**\\n   * @notice Calculates the digest hash to be signed and used in the `delegateToBySignature` function\\n   * @param staker The signing staker\\n   * @param _stakerNonce The nonce of the staker. In practice we use the staker's current nonce, stored at `stakerNonce[staker]`\\n   * @param operator The operator who is being delegated to\\n   * @param expiry The desired expiry time of the staker's signature\\n   */\\n  function calculateStakerDelegationDigestHash(\\n    address staker,\\n    uint256 _stakerNonce,\\n    address operator,\\n    uint256 expiry\\n  ) external view returns (bytes32);\\n\\n  /**\\n   * @notice Calculates the digest hash to be signed by the operator's delegationApprove and used in the `delegateTo` and `delegateToBySignature` functions.\\n   * @param staker The account delegating their stake\\n   * @param operator The account receiving delegated stake\\n   * @param _delegationApprover the operator's `delegationApprover` who will be signing the delegationHash (in general)\\n   * @param approverSalt A unique and single use value associated with the approver signature.\\n   * @param expiry Time after which the approver's signature becomes invalid\\n   */\\n  function calculateDelegationApprovalDigestHash(\\n    address staker,\\n    address operator,\\n    address _delegationApprover,\\n    bytes32 approverSalt,\\n    uint256 expiry\\n  ) external view returns (bytes32);\\n\\n  /// @notice The EIP-712 typehash for the contract's domain\\n  function DOMAIN_TYPEHASH() external view returns (bytes32);\\n\\n  /// @notice The EIP-712 typehash for the StakerDelegation struct used by the contract\\n  function STAKER_DELEGATION_TYPEHASH() external view returns (bytes32);\\n\\n  /// @notice The EIP-712 typehash for the DelegationApproval struct used by the contract\\n  function DELEGATION_APPROVAL_TYPEHASH() external view returns (bytes32);\\n\\n  /**\\n   * @notice Getter function for the current EIP-712 domain separator for this contract.\\n   *\\n   * @dev The domain separator will change in the event of a fork that changes the ChainID.\\n   * @dev By introducing a domain separator the DApp developers are guaranteed that there can be no signature collision.\\n   * for more detailed information please read EIP-712.\\n   */\\n  function domainSeparator() external view returns (bytes32);\\n\\n  /// @notice Mapping: staker => cumulative number of queued withdrawals they have ever initiated.\\n  /// @dev This only increments (doesn't decrement), and is used to help ensure that otherwise identical withdrawals have unique hashes.\\n  function cumulativeWithdrawalsQueued(address staker) external view returns (uint256);\\n\\n  /// @notice Returns the keccak256 hash of `withdrawal`.\\n  function calculateWithdrawalRoot(Withdrawal memory withdrawal) external pure returns (bytes32);\\n}\\n\",\"keccak256\":\"0x060f42bdc248bba590745270397adb9805777f8c6d134ca88a4280da5b0e715a\",\"license\":\"LGPL-3.0\"},\"contracts/interfaces/IPausable.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0\\npragma solidity 0.8.20;\\n\\nimport '../interfaces/IPauserRegistry.sol';\\n\\n/**\\n * @title Adds pausability to a contract, with pausing & unpausing controlled by the `pauser` and `unpauser` of a PauserRegistry contract.\\n * @notice Contracts that inherit from this contract may define their own `pause` and `unpause` (and/or related) functions.\\n * These functions should be permissioned as \\\"onlyPauser\\\" which defers to a `PauserRegistry` for determining access control.\\n * @dev Pausability is implemented using a uint256, which allows up to 256 different single bit-flags; each bit can potentially pause different functionality.\\n * Inspiration for this was taken from the NearBridge design here https://etherscan.io/address/0x3FEFc5A4B1c02f21cBc8D3613643ba0635b9a873#code.\\n * For the `pause` and `unpause` functions we've implemented, if you pause, you can only flip (any number of) switches to on/1 (aka \\\"paused\\\"), and if you unpause,\\n * you can only flip (any number of) switches to off/0 (aka \\\"paused\\\").\\n * If you want a pauseXYZ function that just flips a single bit / \\\"pausing flag\\\", it will:\\n * 1) 'bit-wise and' (aka `&`) a flag with the current paused state (as a uint256)\\n * 2) update the paused state to this new value\\n * @dev We note as well that we have chosen to identify flags by their *bit index* as opposed to their numerical value, so, e.g. defining `DEPOSITS_PAUSED = 3`\\n * indicates specifically that if the *third bit* of `_paused` is flipped -- i.e. it is a '1' -- then deposits should be paused\\n */\\n\\ninterface IPausable {\\n  /// @notice Emitted when the `pauserRegistry` is set to `newPauserRegistry`.\\n  event PauserRegistrySet(IPauserRegistry pauserRegistry, IPauserRegistry newPauserRegistry);\\n\\n  /// @notice Emitted when the pause is triggered by `account`, and changed to `newPausedStatus`.\\n  event Paused(address indexed account, uint256 newPausedStatus);\\n\\n  /// @notice Emitted when the pause is lifted by `account`, and changed to `newPausedStatus`.\\n  event Unpaused(address indexed account, uint256 newPausedStatus);\\n\\n  /// @notice Address of the `PauserRegistry` contract that this contract defers to for determining access control (for pausing).\\n  function pauserRegistry() external view returns (IPauserRegistry);\\n\\n  /**\\n   * @notice This function is used to pause an BinLayer contract's functionality.\\n   * It is permissioned to the `pauser` address, which is expected to be a low threshold multisig.\\n   * @param newPausedStatus represents the new value for `_paused` to take, which means it may flip several bits at once.\\n   * @dev This function can only pause functionality, and thus cannot 'unflip' any bit in `_paused` from 1 to 0.\\n   */\\n  function pause(uint256 newPausedStatus) external;\\n\\n  /**\\n   * @notice Alias for `pause(type(uint256).max)`.\\n   */\\n  function pauseAll() external;\\n\\n  /**\\n   * @notice This function is used to unpause an BinLayer contract's functionality.\\n   * It is permissioned to the `unpauser` address, which is expected to be a high threshold multisig or governance contract.\\n   * @param newPausedStatus represents the new value for `_paused` to take, which means it may flip several bits at once.\\n   * @dev This function can only unpause functionality, and thus cannot 'flip' any bit in `_paused` from 0 to 1.\\n   */\\n  function unpause(uint256 newPausedStatus) external;\\n\\n  /// @notice Returns the current paused status as a uint256.\\n  function paused() external view returns (uint256);\\n\\n  /// @notice Returns 'true' if the `indexed`th bit of `_paused` is 1, and 'false' otherwise\\n  function paused(uint8 index) external view returns (bool);\\n\\n  /// @notice Allows the unpauser to set a new pauser registry\\n  function setPauserRegistry(IPauserRegistry newPauserRegistry) external;\\n}\\n\",\"keccak256\":\"0xf7d61224369ca117fb3601b8de530f800f1dc786ab91c678ab1ab41dc61b059a\",\"license\":\"LGPL-3.0\"},\"contracts/interfaces/IPauserRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0\\npragma solidity 0.8.20;\\n\\n/**\\n * @title Interface for the `PauserRegistry` contract.\\n */\\ninterface IPauserRegistry {\\n  event PauserStatusChanged(address pauser, bool canPause);\\n\\n  event UnpauserChanged(address previousUnpauser, address newUnpauser);\\n\\n  /// @notice Mapping of addresses to whether they hold the pauser role.\\n  function isPauser(address pauser) external view returns (bool);\\n\\n  /// @notice Unique address that holds the unpauser role. Capable of changing *both* the pauser and unpauser addresses.\\n  function unpauser() external view returns (address);\\n}\\n\",\"keccak256\":\"0x55bbced6095c87669e298ee7818c4d1df93fb9988965009594fe8facb2065b46\",\"license\":\"LGPL-3.0\"},\"contracts/interfaces/ISignatureUtils.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0\\npragma solidity 0.8.20;\\n\\n/**\\n * @title The interface for common signature utilities.\\n */\\ninterface ISignatureUtils {\\n  // @notice Struct that bundles together a signature and an expiration time for the signature. Used primarily for stack management.\\n  struct SignatureWithExpiry {\\n    // the signature itself, formatted as a single bytes object\\n    bytes signature;\\n    // the expiration timestamp (UTC) of the signature\\n    uint256 expiry;\\n  }\\n\\n  // @notice Struct that bundles together a signature, a salt for uniqueness, and an expiration time for the signature. Used primarily for stack management.\\n  struct SignatureWithSaltAndExpiry {\\n    // the signature itself, formatted as a single bytes object\\n    bytes signature;\\n    // the salt used to generate the signature\\n    bytes32 salt;\\n    // the expiration timestamp (UTC) of the signature\\n    uint256 expiry;\\n  }\\n}\\n\",\"keccak256\":\"0xd2f901c14d08037588427527905fafbe1610b68a38d62c93925ea0f258f226a4\",\"license\":\"LGPL-3.0\"},\"contracts/interfaces/ISlasher.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0\\npragma solidity 0.8.20;\\n\\nimport './IStrategyManager.sol';\\nimport './IDelegationManager.sol';\\n\\n/**\\n * @title Interface for the primary 'slashing' contract for BinLayer.\\n * @notice See the `Slasher` contract itself for implementation details.\\n */\\ninterface ISlasher {\\n  // struct used to store information about the current state of an operator's obligations to middlewares they are serving\\n  struct MiddlewareTimes {\\n    // The update timestamp for the middleware whose most recent update was earliest, i.e. the 'stalest' update out of all middlewares the operator is serving\\n    uint32 stalestUpdateTimestamp;\\n    // The latest 'serveUntilTimestamp' from all of the middleware that the operator is serving\\n    uint32 latestServeUntilTimestamp;\\n  }\\n\\n  // struct used to store details relevant to a single middleware that an operator has opted-in to serving\\n  struct MiddlewareDetails {\\n    // the timestamp at which the contract begins being able to finalize the operator's registration with the service via calling `recordFirstStakeUpdate`\\n    uint32 registrationMayBeginAtTimestamp;\\n    // the timestamp before which the contract is allowed to slash the user\\n    uint32 contractCanSlashOperatorUntilTimestamp;\\n    // the timestamp at which the middleware's view of the operator's stake was most recently updated\\n    uint32 latestUpdateTimestamp;\\n  }\\n\\n  /// @notice Emitted when a middleware times is added to `operator`'s array.\\n  event MiddlewareTimesAdded(address operator, uint256 index, uint32 stalestUpdateTimestamp, uint32 latestServeUntilTimestamp);\\n\\n  /// @notice Emitted when `operator` begins to allow `contractAddress` to slash them.\\n  event OptedIntoSlashing(address indexed operator, address indexed contractAddress);\\n\\n  /// @notice Emitted when `contractAddress` signals that it will no longer be able to slash `operator` after the `contractCanSlashOperatorUntilTimestamp`.\\n  event SlashingAbilityRevoked(address indexed operator, address indexed contractAddress, uint32 contractCanSlashOperatorUntilTimestamp);\\n\\n  /**\\n   * @notice Emitted when `slashingContract` 'freezes' the `slashedOperator`.\\n   * @dev The `slashingContract` must have permission to slash the `slashedOperator`, i.e. `canSlash(slasherOperator, slashingContract)` must return 'true'.\\n   */\\n  event OperatorFrozen(address indexed slashedOperator, address indexed slashingContract);\\n\\n  /// @notice Emitted when `previouslySlashedAddress` is 'unfrozen', allowing them to again move deposited funds within BinLayer.\\n  event FrozenStatusReset(address indexed previouslySlashedAddress);\\n\\n  /**\\n   * @notice Gives the `contractAddress` permission to slash the funds of the caller.\\n   * @dev Typically, this function must be called prior to registering for a middleware.\\n   */\\n  function optIntoSlashing(address contractAddress) external;\\n\\n  /**\\n   * @notice Used for 'slashing' a certain operator.\\n   * @param toBeFrozen The operator to be frozen.\\n   * @dev Technically the operator is 'frozen' (hence the name of this function), and then subject to slashing pending a decision by a human-in-the-loop.\\n   * @dev The operator must have previously given the caller (which should be a contract) the ability to slash them, through a call to `optIntoSlashing`.\\n   */\\n  function freezeOperator(address toBeFrozen) external;\\n\\n  /**\\n   * @notice Removes the 'frozen' status from each of the `frozenAddresses`\\n   * @dev Callable only by the contract owner (i.e. governance).\\n   */\\n  function resetFrozenStatus(address[] calldata frozenAddresses) external;\\n\\n  /**\\n   * @notice this function is a called by middlewares during an operator's registration to make sure the operator's stake at registration\\n   *         is slashable until serveUntil\\n   * @param operator the operator whose stake update is being recorded\\n   * @param serveUntilTimestamp the timestamp until which the operator's stake at the current timestamp is slashable\\n   * @dev adds the middleware's slashing contract to the operator's linked list\\n   */\\n  function recordFirstStakeUpdate(address operator, uint32 serveUntilTimestamp) external;\\n\\n  /**\\n   * @notice this function is a called by middlewares during a stake update for an operator (perhaps to free pending withdrawals)\\n   *         to make sure the operator's stake at updateTimestamp is slashable until serveUntil\\n   * @param operator the operator whose stake update is being recorded\\n   * @param updateTimestamp the timestamp for which the stake update is being recorded\\n   * @param serveUntilTimestamp the timestamp until which the operator's stake at updateTimestamp is slashable\\n   * @param insertAfter the element of the operators linked list that the currently updating middleware should be inserted after\\n   * @dev insertAfter should be calculated offchain before making the transaction that calls this. this is subject to race conditions,\\n   *      but it is anticipated to be rare and not detrimental.\\n   */\\n  function recordStakeUpdate(address operator, uint32 updateTimestamp, uint32 serveUntilTimestamp, uint256 insertAfter) external;\\n\\n  /**\\n   * @notice this function is a called by middlewares during an operator's deregistration to make sure the operator's stake at deregistration\\n   *         is slashable until serveUntil\\n   * @param operator the operator whose stake update is being recorded\\n   * @param serveUntilTimestamp the timestamp until which the operator's stake at the current timestamp is slashable\\n   * @dev removes the middleware's slashing contract to the operator's linked list and revokes the middleware's (i.e. caller's) ability to\\n   * slash `operator` once `serveUntil` is reached\\n   */\\n  function recordLastStakeUpdateAndRevokeSlashingAbility(address operator, uint32 serveUntilTimestamp) external;\\n\\n  /// @notice The StrategyManager contract of BinLayer\\n  function strategyManager() external view returns (IStrategyManager);\\n\\n  /// @notice The DelegationManager contract of BinLayer\\n  function delegation() external view returns (IDelegationManager);\\n\\n  /**\\n   * @notice Used to determine whether `staker` is actively 'frozen'. If a staker is frozen, then they are potentially subject to\\n   * slashing of their funds, and cannot cannot deposit or withdraw from the strategyManager until the slashing process is completed\\n   * and the staker's status is reset (to 'unfrozen').\\n   * @param staker The staker of interest.\\n   * @return Returns 'true' if `staker` themselves has their status set to frozen, OR if the staker is delegated\\n   * to an operator who has their status set to frozen. Otherwise returns 'false'.\\n   */\\n  function isFrozen(address staker) external view returns (bool);\\n\\n  /// @notice Returns true if `slashingContract` is currently allowed to slash `toBeSlashed`.\\n  function canSlash(address toBeSlashed, address slashingContract) external view returns (bool);\\n\\n  /// @notice Returns the timestamp until which `serviceContract` is allowed to slash the `operator`.\\n  function contractCanSlashOperatorUntilTimestamp(address operator, address serviceContract) external view returns (uint32);\\n\\n  /// @notice Returns the timestamp at which the `serviceContract` last updated its view of the `operator`'s stake\\n  function latestUpdateTimestamp(address operator, address serviceContract) external view returns (uint32);\\n\\n  /// @notice A search routine for finding the correct input value of `insertAfter` to `recordStakeUpdate` / `_updateMiddlewareList`.\\n  function getCorrectValueForInsertAfter(address operator, uint32 updateTimestamp) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns 'true' if `operator` can currently complete a withdrawal started at the `withdrawalStartTimestamp`, with `middlewareTimesIndex` used\\n   * to specify the index of a `MiddlewareTimes` struct in the operator's list (i.e. an index in `operatorToMiddlewareTimes[operator]`). The specified\\n   * struct is consulted as proof of the `operator`'s ability (or lack thereof) to complete the withdrawal.\\n   * This function will return 'false' if the operator cannot currently complete a withdrawal started at the `withdrawalStartTimestamp`, *or* in the event\\n   * that an incorrect `middlewareTimesIndex` is supplied, even if one or more correct inputs exist.\\n   * @param operator Either the operator who queued the withdrawal themselves, or if the withdrawing party is a staker who delegated to an operator,\\n   * this address is the operator *who the staker was delegated to* at the time of the `withdrawalStartTimestamp`.\\n   * @param withdrawalStartTimestamp The timestamp at which the withdrawal was initiated.\\n   * @param middlewareTimesIndex Indicates an index in `operatorToMiddlewareTimes[operator]` to consult as proof of the `operator`'s ability to withdraw\\n   * @dev The correct `middlewareTimesIndex` input should be computable off-chain.\\n   */\\n  function canWithdraw(address operator, uint32 withdrawalStartTimestamp, uint256 middlewareTimesIndex) external returns (bool);\\n\\n  /**\\n   * operator =>\\n   *  [\\n   *      (\\n   *          the least recent update timestamp of all of the middlewares it's serving/served,\\n   *          latest time that the stake bonded at that update needed to serve until\\n   *      )\\n   *  ]\\n   */\\n  function operatorToMiddlewareTimes(address operator, uint256 arrayIndex) external view returns (MiddlewareTimes memory);\\n\\n  /// @notice Getter function for fetching `operatorToMiddlewareTimes[operator].length`\\n  function middlewareTimesLength(address operator) external view returns (uint256);\\n\\n  /// @notice Getter function for fetching `operatorToMiddlewareTimes[operator][index].stalestUpdateTimestamp`.\\n  function getMiddlewareTimesIndexStalestUpdateTimestamp(address operator, uint32 index) external view returns (uint32);\\n\\n  /// @notice Getter function for fetching `operatorToMiddlewareTimes[operator][index].latestServeUntil`.\\n  function getMiddlewareTimesIndexServeUntilTimestamp(address operator, uint32 index) external view returns (uint32);\\n\\n  /// @notice Getter function for fetching `_operatorToWhitelistedContractsByUpdate[operator].size`.\\n  function operatorWhitelistedContractsLinkedListSize(address operator) external view returns (uint256);\\n\\n  /// @notice Getter function for fetching a single node in the operator's linked list (`_operatorToWhitelistedContractsByUpdate[operator]`).\\n  function operatorWhitelistedContractsLinkedListEntry(address operator, address node) external view returns (bool, uint256, uint256);\\n}\\n\",\"keccak256\":\"0xf4d05322d31de185a4f3761538375a9461dc15c4a37582e0a1cbf1ed07105594\",\"license\":\"LGPL-3.0\"},\"contracts/interfaces/IStrategy.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0\\npragma solidity 0.8.20;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\n/**\\n * @title Minimal interface for an `Strategy` contract.\\n * @notice Custom `Strategy` implementations may expand extensively on this interface.\\n */\\ninterface IStrategy {\\n  /**\\n   * @notice Used to deposit tokens into this Strategy\\n   * @param token is the ERC20 token being deposited\\n   * @param amount is the amount of token being deposited\\n   * @dev This function is only callable by the strategyManager contract. It is invoked inside of the strategyManager's\\n   * `depositIntoStrategy` function, and individual share balances are recorded in the strategyManager as well.\\n   * @return newShares is the number of new shares issued at the current exchange ratio.\\n   */\\n  function deposit(IERC20 token, uint256 amount) external returns (uint256);\\n\\n  /**\\n   * @notice Used to withdraw tokens from this Strategy, to the `recipient`'s address\\n   * @param recipient is the address to receive the withdrawn funds\\n   * @param token is the ERC20 token being transferred out\\n   * @param amountShares is the amount of shares being withdrawn\\n   * @dev This function is only callable by the strategyManager contract. It is invoked inside of the strategyManager's\\n   * other functions, and individual share balances are recorded in the strategyManager as well.\\n   */\\n  function withdraw(address recipient, IERC20 token, uint256 amountShares) external;\\n\\n  /**\\n   * @notice Used to convert a number of shares to the equivalent amount of underlying tokens for this strategy.\\n   * @notice In contrast to `sharesToUnderlyingView`, this function **may** make state modifications\\n   * @param amountShares is the amount of shares to calculate its conversion into the underlying token\\n   * @return The amount of underlying tokens corresponding to the input `amountShares`\\n   * @dev Implementation for these functions in particular may vary significantly for different strategies\\n   */\\n  function sharesToUnderlying(uint256 amountShares) external returns (uint256);\\n\\n  /**\\n   * @notice Used to convert an amount of underlying tokens to the equivalent amount of shares in this strategy.\\n   * @notice In contrast to `underlyingToSharesView`, this function **may** make state modifications\\n   * @param amountUnderlying is the amount of `underlyingToken` to calculate its conversion into strategy shares\\n   * @return The amount of underlying tokens corresponding to the input `amountShares`\\n   * @dev Implementation for these functions in particular may vary significantly for different strategies\\n   */\\n  function underlyingToShares(uint256 amountUnderlying) external returns (uint256);\\n\\n  /**\\n   * @notice convenience function for fetching the current underlying value of all of the `user`'s shares in\\n   * this strategy. In contrast to `userUnderlyingView`, this function **may** make state modifications\\n   */\\n  function userUnderlying(address user) external returns (uint256);\\n\\n  /**\\n   * @notice convenience function for fetching the current total shares of `user` in this strategy, by\\n   * querying the `strategyManager` contract\\n   */\\n  function shares(address user) external view returns (uint256);\\n\\n  /**\\n   * @notice Used to convert a number of shares to the equivalent amount of underlying tokens for this strategy.\\n   * @notice In contrast to `sharesToUnderlying`, this function guarantees no state modifications\\n   * @param amountShares is the amount of shares to calculate its conversion into the underlying token\\n   * @return The amount of shares corresponding to the input `amountUnderlying`\\n   * @dev Implementation for these functions in particular may vary significantly for different strategies\\n   */\\n  function sharesToUnderlyingView(uint256 amountShares) external view returns (uint256);\\n\\n  /**\\n   * @notice Used to convert an amount of underlying tokens to the equivalent amount of shares in this strategy.\\n   * @notice In contrast to `underlyingToShares`, this function guarantees no state modifications\\n   * @param amountUnderlying is the amount of `underlyingToken` to calculate its conversion into strategy shares\\n   * @return The amount of shares corresponding to the input `amountUnderlying`\\n   * @dev Implementation for these functions in particular may vary significantly for different strategies\\n   */\\n  function underlyingToSharesView(uint256 amountUnderlying) external view returns (uint256);\\n\\n  /**\\n   * @notice convenience function for fetching the current underlying value of all of the `user`'s shares in\\n   * this strategy. In contrast to `userUnderlying`, this function guarantees no state modifications\\n   */\\n  function userUnderlyingView(address user) external view returns (uint256);\\n\\n  /// @notice The underlying token for shares in this Strategy\\n  function underlyingToken() external view returns (IERC20);\\n\\n  /// @notice The total number of extant shares in this Strategy\\n  function totalShares() external view returns (uint256);\\n\\n  /// @notice Returns either a brief string explaining the strategy's goal & purpose, or a link to metadata that explains in more detail.\\n  function explanation() external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x3435d819a62bf13c8f41498f27fb2117adb2095890b75b86005af1ed238a78bb\",\"license\":\"LGPL-3.0\"},\"contracts/interfaces/IStrategyManager.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0\\npragma solidity 0.8.20;\\n\\nimport './IStrategy.sol';\\nimport './ISlasher.sol';\\nimport './IDelegationManager.sol';\\n\\n/**\\n * @title Interface for the primary entrypoint for funds into BinLayer.\\n * @notice See the `StrategyManager` contract itself for implementation details.\\n */\\ninterface IStrategyManager {\\n  /**\\n   * @notice Emitted when a new deposit occurs on behalf of `staker`.\\n   * @param staker Is the staker who is depositing funds into BinLayer.\\n   * @param strategy Is the strategy that `staker` has deposited into.\\n   * @param token Is the token that `staker` deposited.\\n   * @param shares Is the number of new shares `staker` has been granted in `strategy`.\\n   */\\n  event Deposit(address staker, IERC20 token, IStrategy strategy, uint256 shares);\\n\\n  /// @notice Emitted when `thirdPartyTransfersForbidden` is updated for a strategy and value by the owner\\n  event UpdatedThirdPartyTransfersForbidden(IStrategy strategy, bool value);\\n\\n  /// @notice Emitted when the `strategyWhitelister` is changed\\n  event StrategyWhitelisterChanged(address previousAddress, address newAddress);\\n\\n  /// @notice Emitted when a strategy is added to the approved list of strategies for deposit\\n  event StrategyAddedToDepositWhitelist(IStrategy strategy);\\n\\n  /// @notice Emitted when a strategy is removed from the approved list of strategies for deposit\\n  event StrategyRemovedFromDepositWhitelist(IStrategy strategy);\\n\\n  /**\\n   * @notice Deposits `amount` of `token` into the specified `strategy`, with the resultant shares credited to `msg.sender`\\n   * @param strategy is the specified strategy where deposit is to be made,\\n   * @param token is the denomination in which the deposit is to be made,\\n   * @param amount is the amount of token to be deposited in the strategy by the staker\\n   * @return shares The amount of new shares in the `strategy` created as part of the action.\\n   * @dev The `msg.sender` must have previously approved this contract to transfer at least `amount` of `token` on their behalf.\\n   * @dev Cannot be called by an address that is 'frozen' (this function will revert if the `msg.sender` is frozen).\\n   *\\n   * WARNING: Depositing tokens that allow reentrancy (eg. ERC-777) into a strategy is not recommended.  This can lead to attack vectors\\n   *          where the token balance and corresponding strategy shares are not in sync upon reentrancy.\\n   */\\n  function depositIntoStrategy(IStrategy strategy, IERC20 token, uint256 amount) external returns (uint256 shares);\\n\\n  /**\\n   * @notice Deposits `amount` of `token` into the specified `strategy`, with the resultant shares credited to `staker`\\n   * @param staker Staker address\\n   * @param strategy is the specified strategy where deposit is to be made,\\n   * @param token is the denomination in which the deposit is to be made,\\n   * @param amount is the amount of token to be deposited in the strategy by the staker\\n   * @return shares The amount of new shares in the `strategy` created as part of the action.\\n   * @dev The `msg.sender` must have previously approved this contract to transfer at least `amount` of `token` on their behalf.\\n   * @dev Cannot be called by an address that is 'frozen' (this function will revert if the `msg.sender` is frozen).\\n   *\\n   * WARNING: Depositing tokens that allow reentrancy (eg. ERC-777) into a strategy is not recommended.  This can lead to attack vectors\\n   *          where the token balance and corresponding strategy shares are not in sync upon reentrancy.\\n   */\\n  function depositIntoStrategyWithStaker(\\n    address staker,\\n    IStrategy strategy,\\n    IERC20 token,\\n    uint256 amount\\n  ) external returns (uint256 shares);\\n\\n  /**\\n   * @notice Used for depositing an asset into the specified strategy with the resultant shares credited to `staker`,\\n   * who must sign off on the action.\\n   * Note that the assets are transferred out/from the `msg.sender`, not from the `staker`; this function is explicitly designed\\n   * purely to help one address deposit 'for' another.\\n   * @param strategy is the specified strategy where deposit is to be made,\\n   * @param token is the denomination in which the deposit is to be made,\\n   * @param amount is the amount of token to be deposited in the strategy by the staker\\n   * @param staker the staker that the deposited assets will be credited to\\n   * @param expiry the timestamp at which the signature expires\\n   * @param signature is a valid signature from the `staker`. either an ECDSA signature if the `staker` is an EOA, or data to forward\\n   * following EIP-1271 if the `staker` is a contract\\n   * @return shares The amount of new shares in the `strategy` created as part of the action.\\n   * @dev The `msg.sender` must have previously approved this contract to transfer at least `amount` of `token` on their behalf.\\n   * @dev A signature is required for this function to eliminate the possibility of griefing attacks, specifically those\\n   * targeting stakers who may be attempting to undelegate.\\n   * @dev Cannot be called if thirdPartyTransfersForbidden is set to true for this strategy\\n   *\\n   *  WARNING: Depositing tokens that allow reentrancy (eg. ERC-777) into a strategy is not recommended.  This can lead to attack vectors\\n   *          where the token balance and corresponding strategy shares are not in sync upon reentrancy\\n   */\\n  function depositIntoStrategyWithSignature(\\n    IStrategy strategy,\\n    IERC20 token,\\n    uint256 amount,\\n    address staker,\\n    uint256 expiry,\\n    bytes memory signature\\n  ) external returns (uint256 shares);\\n\\n  /// @notice Used by the DelegationManager to remove a Staker's shares from a particular strategy when entering the withdrawal queue\\n  function removeShares(address staker, IStrategy strategy, uint256 shares) external;\\n\\n  /// @notice Used by the DelegationManager to award a Staker some shares that have passed through the withdrawal queue\\n  function addShares(address staker, IERC20 token, IStrategy strategy, uint256 shares) external;\\n\\n  /// @notice Used by the DelegationManager to convert withdrawn shares to tokens and send them to a recipient\\n  function withdrawSharesAsTokens(address recipient, IStrategy strategy, uint256 shares, IERC20 token) external;\\n\\n  /// @notice Returns the current shares of `user` in `strategy`\\n  function stakerStrategyShares(address user, IStrategy strategy) external view returns (uint256 shares);\\n\\n  /**\\n   * @notice Get all details on the staker's deposits and corresponding shares\\n   * @return (staker's strategies, shares in these strategies)\\n   */\\n  function getDeposits(address staker) external view returns (IStrategy[] memory, uint256[] memory);\\n\\n  /// @notice Simple getter function that returns `stakerStrategyList[staker].length`.\\n  function stakerStrategyListLength(address staker) external view returns (uint256);\\n\\n  /**\\n   * @notice Owner-only function that adds the provided Strategies to the 'whitelist' of strategies that stakers can deposit into\\n   * @param strategiesToWhitelist Strategies that will be added to the `strategyIsWhitelistedForDeposit` mapping (if they aren't in it already)\\n   * @param thirdPartyTransfersForbiddenValues bool values to set `thirdPartyTransfersForbidden` to for each strategy\\n   */\\n  function addStrategiesToDepositWhitelist(\\n    IStrategy[] calldata strategiesToWhitelist,\\n    bool[] calldata thirdPartyTransfersForbiddenValues\\n  ) external;\\n\\n  /**\\n   * @notice Owner-only function that removes the provided Strategies from the 'whitelist' of strategies that stakers can deposit into\\n   * @param strategiesToRemoveFromWhitelist Strategies that will be removed to the `strategyIsWhitelistedForDeposit` mapping (if they are in it)\\n   */\\n  function removeStrategiesFromDepositWhitelist(IStrategy[] calldata strategiesToRemoveFromWhitelist) external;\\n\\n  /// @notice Returns the single, central Delegation contract of BinLayer\\n  function delegation() external view returns (IDelegationManager);\\n\\n  /// @notice Returns the single, central Slasher contract of BinLayer\\n  function slasher() external view returns (ISlasher);\\n\\n  /// @notice Returns the address of the `strategyWhitelister`\\n  function strategyWhitelister() external view returns (address);\\n\\n  /**\\n   * @notice Returns bool for whether or not `strategy` enables credit transfers. i.e enabling\\n   * depositIntoStrategyWithSignature calls or queueing withdrawals to a different address than the staker.\\n   */\\n  function thirdPartyTransfersForbidden(IStrategy strategy) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5c8847f82df9b922c73085e105fd62e461e72b4b0ed344776dd81c732d1137ad\",\"license\":\"LGPL-3.0\"},\"contracts/permissions/Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0\\n\\npragma solidity 0.8.20;\\n\\nimport '../interfaces/IPausable.sol';\\n\\n/**\\n * @title Adds pausability to a contract, with pausing & unpausing controlled by the `pauser` and `unpauser` of a PauserRegistry contract.\\n * @notice Contracts that inherit from this contract may define their own `pause` and `unpause` (and/or related) functions.\\n * These functions should be permissioned as \\\"onlyPauser\\\" which defers to a `PauserRegistry` for determining access control.\\n * @dev Pausability is implemented using a uint256, which allows up to 256 different single bit-flags; each bit can potentially pause different functionality.\\n * Inspiration for this was taken from the NearBridge design here https://etherscan.io/address/0x3FEFc5A4B1c02f21cBc8D3613643ba0635b9a873#code.\\n * For the `pause` and `unpause` functions we've implemented, if you pause, you can only flip (any number of) switches to on/1 (aka \\\"paused\\\"), and if you unpause,\\n * you can only flip (any number of) switches to off/0 (aka \\\"paused\\\").\\n * If you want a pauseXYZ function that just flips a single bit / \\\"pausing flag\\\", it will:\\n * 1) 'bit-wise and' (aka `&`) a flag with the current paused state (as a uint256)\\n * 2) update the paused state to this new value\\n * @dev We note as well that we have chosen to identify flags by their *bit index* as opposed to their numerical value, so, e.g. defining `DEPOSITS_PAUSED = 3`\\n * indicates specifically that if the *third bit* of `_paused` is flipped -- i.e. it is a '1' -- then deposits should be paused\\n */\\ncontract Pausable is IPausable {\\n  /// @notice Address of the `PauserRegistry` contract that this contract defers to for determining access control (for pausing).\\n  IPauserRegistry public pauserRegistry;\\n\\n  /// @dev whether or not the contract is currently paused\\n  uint256 private _paused;\\n\\n  uint256 internal constant UNPAUSE_ALL = 0;\\n  uint256 internal constant PAUSE_ALL = type(uint256).max;\\n\\n  /// @notice\\n  modifier onlyPauser() {\\n    require(pauserRegistry.isPauser(msg.sender), 'msg.sender is not permissioned as pauser');\\n    _;\\n  }\\n\\n  modifier onlyUnpauser() {\\n    require(msg.sender == pauserRegistry.unpauser(), 'msg.sender is not permissioned as unpauser');\\n    _;\\n  }\\n\\n  /// @notice Throws if the contract is paused, i.e. if any of the bits in `_paused` is flipped to 1.\\n  modifier whenNotPaused() {\\n    require(_paused == 0, 'Pausable: contract is paused');\\n    _;\\n  }\\n\\n  /// @notice Throws if the `indexed`th bit of `_paused` is 1, i.e. if the `index`th pause switch is flipped.\\n  modifier onlyWhenNotPaused(uint8 index) {\\n    require(!paused(index), 'Pausable: index is paused');\\n    _;\\n  }\\n\\n  /// @notice One-time function for setting the `pauserRegistry` and initializing the value of `_paused`.\\n  function _initializePauser(IPauserRegistry _pauserRegistry, uint256 initPausedStatus) internal {\\n    require(\\n      address(pauserRegistry) == address(0) && address(_pauserRegistry) != address(0),\\n      'Pausable._initializePauser: _initializePauser() can only be called once'\\n    );\\n    _paused = initPausedStatus;\\n    emit Paused(msg.sender, initPausedStatus);\\n    _setPauserRegistry(_pauserRegistry);\\n  }\\n\\n  /**\\n   * @notice This function is used to pause an BinLayer contract's functionality.\\n   * It is permissioned to the `pauser` address, which is expected to be a low threshold multisig.\\n   * @param newPausedStatus represents the new value for `_paused` to take, which means it may flip several bits at once.\\n   * @dev This function can only pause functionality, and thus cannot 'unflip' any bit in `_paused` from 1 to 0.\\n   */\\n  function pause(uint256 newPausedStatus) external onlyPauser {\\n    // verify that the `newPausedStatus` does not *unflip* any bits (i.e. doesn't unpause anything, all 1 bits remain)\\n    require((_paused & newPausedStatus) == _paused, 'Pausable.pause: invalid attempt to unpause functionality');\\n    _paused = newPausedStatus;\\n    emit Paused(msg.sender, newPausedStatus);\\n  }\\n\\n  /**\\n   * @notice Alias for `pause(type(uint256).max)`.\\n   */\\n  function pauseAll() external onlyPauser {\\n    _paused = type(uint256).max;\\n    emit Paused(msg.sender, type(uint256).max);\\n  }\\n\\n  /**\\n   * @notice This function is used to unpause an BinLayer contract's functionality.\\n   * It is permissioned to the `unpauser` address, which is expected to be a high threshold multisig or governance contract.\\n   * @param newPausedStatus represents the new value for `_paused` to take, which means it may flip several bits at once.\\n   * @dev This function can only unpause functionality, and thus cannot 'flip' any bit in `_paused` from 0 to 1.\\n   */\\n  function unpause(uint256 newPausedStatus) external onlyUnpauser {\\n    // verify that the `newPausedStatus` does not *flip* any bits (i.e. doesn't pause anything, all 0 bits remain)\\n    require(((~_paused) & (~newPausedStatus)) == (~_paused), 'Pausable.unpause: invalid attempt to pause functionality');\\n    _paused = newPausedStatus;\\n    emit Unpaused(msg.sender, newPausedStatus);\\n  }\\n\\n  /// @notice Returns the current paused status as a uint256.\\n  function paused() public view virtual returns (uint256) {\\n    return _paused;\\n  }\\n\\n  /// @notice Returns 'true' if the `indexed`th bit of `_paused` is 1, and 'false' otherwise\\n  function paused(uint8 index) public view virtual returns (bool) {\\n    uint256 mask = 1 << index;\\n    return ((_paused & mask) == mask);\\n  }\\n\\n  /// @notice Allows the unpauser to set a new pauser registry\\n  function setPauserRegistry(IPauserRegistry newPauserRegistry) external onlyUnpauser {\\n    _setPauserRegistry(newPauserRegistry);\\n  }\\n\\n  /// internal function for setting pauser registry\\n  function _setPauserRegistry(IPauserRegistry newPauserRegistry) internal {\\n    require(address(newPauserRegistry) != address(0), 'Pausable._setPauserRegistry: newPauserRegistry cannot be the zero address');\\n    emit PauserRegistrySet(pauserRegistry, newPauserRegistry);\\n    pauserRegistry = newPauserRegistry;\\n  }\\n\\n  /**\\n   * @dev This empty reserved space is put in place to allow future versions to add new\\n   * variables without shifting down storage in the inheritance chain.\\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n   */\\n  uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x309c3d17c29e28fd3760fbed15c6e3cb2a16b31922501554b2d2760797f60459\",\"license\":\"LGPL-3.0\"},\"contracts/strategies/StrategyBase.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0\\npragma solidity 0.8.20;\\n\\nimport '../interfaces/IStrategyManager.sol';\\nimport '../permissions/Pausable.sol';\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\\n\\n/**\\n * @title Base implementation of `IStrategy` interface, designed to be inherited from by more complex strategies.\\n * @notice Simple, basic, \\\"do-nothing\\\" Strategy that holds a single underlying token and returns it on withdrawals.\\n * Implements minimal versions of the IStrategy functions, this contract is designed to be inherited by\\n * more complex strategies, which can then override its functions as necessary.\\n * @dev Note that some functions have their mutability restricted; developers inheriting from this contract cannot broaden\\n * the mutability without modifying this contract itself.\\n * @dev This contract is expressly *not* intended for use with 'fee-on-transfer'-type tokens.\\n * Setting the `underlyingToken` to be a fee-on-transfer token may result in improper accounting.\\n * @notice This contract functions similarly to an ERC4626 vault, only without issuing a token.\\n * To mitigate against the common \\\"inflation attack\\\" vector, we have chosen to use the 'virtual shares' mitigation route,\\n * similar to [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC4626.sol).\\n * We acknowledge that this mitigation has the known downside of the virtual shares causing some losses to users, which are pronounced\\n * particularly in the case of the share exchange rate changing signficantly, either positively or negatively.\\n * For a fairly thorough discussion of this issue and our chosen mitigation strategy, we recommend reading through\\n * [this thread](https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3706) on the OpenZeppelin repo.\\n * We specifically use a share offset of `SHARES_OFFSET` and a balance offset of `BALANCE_OFFSET`.\\n */\\ncontract StrategyBase is Initializable, Pausable, IStrategy {\\n  using SafeERC20 for IERC20;\\n\\n  uint8 internal constant PAUSED_DEPOSITS = 0;\\n  uint8 internal constant PAUSED_WITHDRAWALS = 1;\\n\\n  /**\\n   * @notice virtual shares used as part of the mitigation of the common 'share inflation' attack vector.\\n   * Constant value chosen to reasonably reduce attempted share inflation by the first depositor, while still\\n   * incurring reasonably small losses to depositors\\n   */\\n  uint256 internal constant SHARES_OFFSET = 1e3;\\n  /**\\n   * @notice virtual balance used as part of the mitigation of the common 'share inflation' attack vector\\n   * Constant value chosen to reasonably reduce attempted share inflation by the first depositor, while still\\n   * incurring reasonably small losses to depositors\\n   */\\n  uint256 internal constant BALANCE_OFFSET = 1e3;\\n\\n  /// @notice BinLayer's StrategyManager contract\\n  /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n  IStrategyManager public immutable strategyManager;\\n\\n  /// @notice The underlying token for shares in this Strategy\\n  IERC20 public underlyingToken;\\n\\n  /// @notice The total number of extant shares in this Strategy\\n  uint256 public totalShares;\\n\\n  /// @notice Simply checks that the `msg.sender` is the `strategyManager`, which is an address stored immutably at construction.\\n  modifier onlyStrategyManager() {\\n    require(msg.sender == address(strategyManager), 'StrategyBase.onlyStrategyManager');\\n    _;\\n  }\\n\\n  /// @notice Since this contract is designed to be initializable, the constructor simply sets `strategyManager`, the only immutable variable.\\n  /// @custom:oz-upgrades-unsafe-allow constructor\\n  constructor(IStrategyManager _strategyManager) {\\n    strategyManager = _strategyManager;\\n    _disableInitializers();\\n  }\\n\\n  function initializeBase(IERC20 _underlyingToken, IPauserRegistry _pauserRegistry) public virtual initializer {\\n    _initializeStrategyBase(_underlyingToken, _pauserRegistry);\\n  }\\n\\n  /// @notice Sets the `underlyingToken` and `pauserRegistry` for the strategy.\\n  function _initializeStrategyBase(IERC20 _underlyingToken, IPauserRegistry _pauserRegistry) internal onlyInitializing {\\n    underlyingToken = _underlyingToken;\\n    _initializePauser(_pauserRegistry, UNPAUSE_ALL);\\n  }\\n\\n  /**\\n   * @notice Used to deposit tokens into this Strategy\\n   * @param token is the ERC20 token being deposited\\n   * @param amount is the amount of token being deposited\\n   * @dev This function is only callable by the strategyManager contract. It is invoked inside of the strategyManager's\\n   * `depositIntoStrategy` function, and individual share balances are recorded in the strategyManager as well.\\n   * @dev Note that the assumption is made that `amount` of `token` has already been transferred directly to this contract\\n   * (as performed in the StrategyManager's deposit functions). In particular, setting the `underlyingToken` of this contract\\n   * to be a fee-on-transfer token will break the assumption that the amount this contract *received* of the token is equal to\\n   * the amount that was input when the transfer was performed (i.e. the amount transferred 'out' of the depositor's balance).\\n   * @dev Note that any validation of `token` is done inside `_beforeDeposit`. This can be overridden if needed.\\n   * @return newShares is the number of new shares issued at the current exchange ratio.\\n   */\\n  function deposit(\\n    IERC20 token,\\n    uint256 amount\\n  ) external virtual override onlyWhenNotPaused(PAUSED_DEPOSITS) onlyStrategyManager returns (uint256 newShares) {\\n    // call hook to allow for any pre-deposit logic\\n    _beforeDeposit(token, amount);\\n\\n    // copy `totalShares` value to memory, prior to any change\\n    uint256 priorTotalShares = totalShares;\\n\\n    /**\\n     * @notice calculation of newShares *mirrors* `underlyingToShares(amount)`, but is different since the balance of `underlyingToken`\\n     * has already been increased due to the `strategyManager` transferring tokens to this strategy prior to calling this function\\n     */\\n    // account for virtual shares and balance\\n    uint256 virtualShareAmount = priorTotalShares + SHARES_OFFSET;\\n    uint256 virtualTokenBalance = _tokenBalance() + BALANCE_OFFSET;\\n    // calculate the prior virtual balance to account for the tokens that were already transferred to this contract\\n    uint256 virtualPriorTokenBalance = virtualTokenBalance - amount;\\n    newShares = (amount * virtualShareAmount) / virtualPriorTokenBalance;\\n\\n    // extra check for correctness / against edge case where share rate can be massively inflated as a 'griefing' sort of attack\\n    require(newShares != 0, 'StrategyBase.deposit: newShares cannot be zero');\\n\\n    // update total share amount to account for deposit\\n    totalShares = (priorTotalShares + newShares);\\n    return newShares;\\n  }\\n\\n  /**\\n   * @notice Used to withdraw tokens from this Strategy, to the `recipient`'s address\\n   * @param recipient is the address to receive the withdrawn funds\\n   * @param token is the ERC20 token being transferred out\\n   * @param amountShares is the amount of shares being withdrawn\\n   * @dev This function is only callable by the strategyManager contract. It is invoked inside of the strategyManager's\\n   * other functions, and individual share balances are recorded in the strategyManager as well.\\n   * @dev Note that any validation of `token` is done inside `_beforeWithdrawal`. This can be overridden if needed.\\n   */\\n  function withdraw(\\n    address recipient,\\n    IERC20 token,\\n    uint256 amountShares\\n  ) external virtual override onlyWhenNotPaused(PAUSED_WITHDRAWALS) onlyStrategyManager {\\n    // call hook to allow for any pre-withdrawal logic\\n    _beforeWithdrawal(recipient, token, amountShares);\\n\\n    // copy `totalShares` value to memory, prior to any change\\n    uint256 priorTotalShares = totalShares;\\n\\n    require(amountShares <= priorTotalShares, 'StrategyBase.withdraw: amountShares must be less than or equal to totalShares');\\n\\n    // account for virtual shares and balance\\n    uint256 virtualPriorTotalShares = priorTotalShares + SHARES_OFFSET;\\n    uint256 virtualTokenBalance = _tokenBalance() + BALANCE_OFFSET;\\n    // calculate ratio based on virtual shares and balance, being careful to multiply before dividing\\n    uint256 amountToSend = (virtualTokenBalance * amountShares) / virtualPriorTotalShares;\\n\\n    // Decrease the `totalShares` value to reflect the withdrawal\\n    totalShares = priorTotalShares - amountShares;\\n\\n    _afterWithdrawal(recipient, token, amountToSend);\\n  }\\n\\n  /**\\n   * @notice Called in the external `deposit` function, before any logic is executed. Expected to be overridden if strategies want such logic.\\n   * @param token The token being deposited\\n   * @param amount The amount of `token` being deposited\\n   */\\n  function _beforeDeposit(IERC20 token, uint256 amount) internal virtual {\\n    require(token == underlyingToken, 'StrategyBase.deposit: Can only deposit underlyingToken');\\n  }\\n\\n  /**\\n   * @notice Called in the external `withdraw` function, before any logic is executed.  Expected to be overridden if strategies want such logic.\\n   * @param recipient The address that will receive the withdrawn tokens\\n   * @param token The token being withdrawn\\n   * @param amountShares The amount of shares being withdrawn\\n   */\\n  function _beforeWithdrawal(address recipient, IERC20 token, uint256 amountShares) internal virtual {\\n    require(token == underlyingToken, 'StrategyBase.withdraw: Can only withdraw the strategy token');\\n  }\\n\\n  /**\\n   * @notice Transfers tokens to the recipient after a withdrawal is processed\\n   * @dev Called in the external `withdraw` function after all logic is executed\\n   * @param recipient The destination of the tokens\\n   * @param token The ERC20 being transferred\\n   * @param amountToSend The amount of `token` to transfer\\n   */\\n  function _afterWithdrawal(address recipient, IERC20 token, uint256 amountToSend) internal virtual {\\n    token.safeTransfer(recipient, amountToSend);\\n  }\\n\\n  /**\\n   * @notice Currently returns a brief string explaining the strategy's goal & purpose, but for more complex\\n   * strategies, may be a link to metadata that explains in more detail.\\n   */\\n  function explanation() external pure virtual override returns (string memory) {\\n    return 'Base Strategy implementation to inherit from for more complex implementations';\\n  }\\n\\n  /**\\n   * @notice Used to convert a number of shares to the equivalent amount of underlying tokens for this strategy.\\n   * @notice In contrast to `sharesToUnderlying`, this function guarantees no state modifications\\n   * @param amountShares is the amount of shares to calculate its conversion into the underlying token\\n   * @return The amount of underlying tokens corresponding to the input `amountShares`\\n   * @dev Implementation for these functions in particular may vary significantly for different strategies\\n   */\\n  function sharesToUnderlyingView(uint256 amountShares) public view virtual override returns (uint256) {\\n    // account for virtual shares and balance\\n    uint256 virtualTotalShares = totalShares + SHARES_OFFSET;\\n    uint256 virtualTokenBalance = _tokenBalance() + BALANCE_OFFSET;\\n    // calculate ratio based on virtual shares and balance, being careful to multiply before dividing\\n    return (virtualTokenBalance * amountShares) / virtualTotalShares;\\n  }\\n\\n  /**\\n   * @notice Used to convert a number of shares to the equivalent amount of underlying tokens for this strategy.\\n   * @notice In contrast to `sharesToUnderlyingView`, this function **may** make state modifications\\n   * @param amountShares is the amount of shares to calculate its conversion into the underlying token\\n   * @return The amount of underlying tokens corresponding to the input `amountShares`\\n   * @dev Implementation for these functions in particular may vary significantly for different strategies\\n   */\\n  function sharesToUnderlying(uint256 amountShares) public view virtual override returns (uint256) {\\n    return sharesToUnderlyingView(amountShares);\\n  }\\n\\n  /**\\n   * @notice Used to convert an amount of underlying tokens to the equivalent amount of shares in this strategy.\\n   * @notice In contrast to `underlyingToShares`, this function guarantees no state modifications\\n   * @param amountUnderlying is the amount of `underlyingToken` to calculate its conversion into strategy shares\\n   * @return The amount of shares corresponding to the input `amountUnderlying`\\n   * @dev Implementation for these functions in particular may vary significantly for different strategies\\n   */\\n  function underlyingToSharesView(uint256 amountUnderlying) public view virtual returns (uint256) {\\n    // account for virtual shares and balance\\n    uint256 virtualTotalShares = totalShares + SHARES_OFFSET;\\n    uint256 virtualTokenBalance = _tokenBalance() + BALANCE_OFFSET;\\n    // calculate ratio based on virtual shares and balance, being careful to multiply before dividing\\n    return (amountUnderlying * virtualTotalShares) / virtualTokenBalance;\\n  }\\n\\n  /**\\n   * @notice Used to convert an amount of underlying tokens to the equivalent amount of shares in this strategy.\\n   * @notice In contrast to `underlyingToSharesView`, this function **may** make state modifications\\n   * @param amountUnderlying is the amount of `underlyingToken` to calculate its conversion into strategy shares\\n   * @return The amount of shares corresponding to the input `amountUnderlying`\\n   * @dev Implementation for these functions in particular may vary significantly for different strategies\\n   */\\n  function underlyingToShares(uint256 amountUnderlying) external view virtual returns (uint256) {\\n    return underlyingToSharesView(amountUnderlying);\\n  }\\n\\n  /**\\n   * @notice convenience function for fetching the current underlying value of all of the `user`'s shares in\\n   * this strategy. In contrast to `userUnderlying`, this function guarantees no state modifications\\n   */\\n  function userUnderlyingView(address user) external view virtual returns (uint256) {\\n    return sharesToUnderlyingView(shares(user));\\n  }\\n\\n  /**\\n   * @notice convenience function for fetching the current underlying value of all of the `user`'s shares in\\n   * this strategy. In contrast to `userUnderlyingView`, this function **may** make state modifications\\n   */\\n  function userUnderlying(address user) external virtual returns (uint256) {\\n    return sharesToUnderlying(shares(user));\\n  }\\n\\n  /**\\n   * @notice convenience function for fetching the current total shares of `user` in this strategy, by\\n   * querying the `strategyManager` contract\\n   */\\n  function shares(address user) public view virtual returns (uint256) {\\n    return strategyManager.stakerStrategyShares(user, IStrategy(address(this)));\\n  }\\n\\n  /// @notice Internal function used to fetch this contract's current balance of `underlyingToken`.\\n  // slither-disable-next-line dead-code\\n  function _tokenBalance() internal view virtual returns (uint256) {\\n    return underlyingToken.balanceOf(address(this));\\n  }\\n\\n  /**\\n   * @dev This empty reserved space is put in place to allow future versions to add new\\n   * variables without shifting down storage in the inheritance chain.\\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n   */\\n  uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x5db2155a29ba0d069491e5f46e6d205042208ef8e69eafaec339770774a59c94\",\"license\":\"LGPL-3.0\"},\"contracts/strategies/StrategyBaseTVLLimits.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0\\npragma solidity 0.8.20;\\n\\nimport './StrategyBase.sol';\\n\\n/**\\n * @title A Strategy implementation inheriting from `StrategyBase` that limits the total amount of deposits it will accept.\\n * @dev Note that this implementation still converts between any amount of shares or underlying tokens in its view functions;\\n * these functions purposefully do not take the TVL limit into account.\\n */\\ncontract StrategyBaseTVLLimits is StrategyBase {\\n  /// The maximum deposit (in underlyingToken) that this strategy will accept per deposit\\n  uint256 public maxPerDeposit;\\n\\n  /// The maximum deposits (in underlyingToken) that this strategy will hold\\n  uint256 public maxTotalDeposits;\\n\\n  /// @notice Emitted when `maxPerDeposit` value is updated from `previousValue` to `newValue`\\n  event MaxPerDepositUpdated(uint256 previousValue, uint256 newValue);\\n\\n  /// @notice Emitted when `maxTotalDeposits` value is updated from `previousValue` to `newValue`\\n  event MaxTotalDepositsUpdated(uint256 previousValue, uint256 newValue);\\n\\n  /// solhint-disable-next-line no-empty-blocks\\n  /// @custom:oz-upgrades-unsafe-allow constructor\\n  constructor(IStrategyManager _strategyManager) StrategyBase(_strategyManager) {}\\n\\n  function initialize(\\n    uint256 _maxPerDeposit,\\n    uint256 _maxTotalDeposits,\\n    IERC20 _underlyingToken,\\n    IPauserRegistry _pauserRegistry\\n  ) public virtual initializer {\\n    _setTVLLimits(_maxPerDeposit, _maxTotalDeposits);\\n    _initializeStrategyBase(_underlyingToken, _pauserRegistry);\\n  }\\n\\n  /**\\n   * @notice Sets the maximum deposits (in underlyingToken) that this strategy will hold and accept per deposit\\n   * @param newMaxTotalDeposits The new maximum deposits\\n   * @dev Callable only by the unpauser of this contract\\n   * @dev We note that there is a potential race condition between a call to this function that lowers either or both of these limits and call(s)\\n   * to `deposit`, that may result in some calls to `deposit` reverting.\\n   */\\n  function setTVLLimits(uint256 newMaxPerDeposit, uint256 newMaxTotalDeposits) external onlyUnpauser {\\n    _setTVLLimits(newMaxPerDeposit, newMaxTotalDeposits);\\n  }\\n\\n  /// @notice Simple getter function that returns the current values of `maxPerDeposit` and `maxTotalDeposits`.\\n  function getTVLLimits() external view returns (uint256, uint256) {\\n    return (maxPerDeposit, maxTotalDeposits);\\n  }\\n\\n  /// @notice Internal setter for TVL limits\\n  function _setTVLLimits(uint256 newMaxPerDeposit, uint256 newMaxTotalDeposits) internal {\\n    emit MaxPerDepositUpdated(maxPerDeposit, newMaxPerDeposit);\\n    emit MaxTotalDepositsUpdated(maxTotalDeposits, newMaxTotalDeposits);\\n    require(newMaxPerDeposit <= newMaxTotalDeposits, 'StrategyBaseTVLLimits._setTVLLimits: maxPerDeposit exceeds maxTotalDeposits');\\n    maxPerDeposit = newMaxPerDeposit;\\n    maxTotalDeposits = newMaxTotalDeposits;\\n  }\\n\\n  /**\\n   * @notice Called in the external `deposit` function, before any logic is executed. Makes sure that deposits don't exceed configured maximum.\\n   * @dev Unused token param is the token being deposited. This is already checked in the `deposit` function.\\n   * @dev Note that the `maxTotalDeposits` is purely checked against the current `_tokenBalance()`, since by this point in the deposit flow, the\\n   * tokens should have already been transferred to this Strategy by the StrategyManager\\n   * @dev We note as well that this makes it possible for various race conditions to occur:\\n   * a) multiple simultaneous calls to `deposit` may result in some of these calls reverting due to `maxTotalDeposits` being reached.\\n   * b) transferring funds directly to this Strategy (although not generally in someone's economic self interest) in order to reach `maxTotalDeposits`\\n   * is a route by which someone can cause calls to `deposit` to revert.\\n   * c) increases in the token balance of this contract through other effects \\u2013 including token rebasing \\u2013 may cause similar issues to (a) and (b).\\n   * @param amount The amount of `token` being deposited\\n   */\\n  function _beforeDeposit(IERC20 token, uint256 amount) internal virtual override {\\n    require(amount <= maxPerDeposit, 'StrategyBaseTVLLimits: max per deposit exceeded');\\n    require(_tokenBalance() <= maxTotalDeposits, 'StrategyBaseTVLLimits: max deposits exceeded');\\n\\n    super._beforeDeposit(token, amount);\\n  }\\n\\n  /**\\n   * @dev This empty reserved space is put in place to allow future versions to add new\\n   * variables without shifting down storage in the inheritance chain.\\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n   */\\n  uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x809e78bf7701b327054990b71480aa76aea39838d419b7701bf13e1646edfe7a\",\"license\":\"LGPL-3.0\"}},\"version\":1}",
  "bytecode": "0x60a06040523480156200001157600080fd5b5060405162001f8238038062001f82833981016040819052620000349162000115565b6001600160a01b038116608052806200004c62000054565b505062000147565b600054610100900460ff1615620000c15760405162461bcd60e51b815260206004820152602760248201527f496e697469616c697a61626c653a20636f6e747261637420697320696e697469604482015266616c697a696e6760c81b606482015260840160405180910390fd5b60005460ff9081161462000113576000805460ff191660ff9081179091556040519081527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b565b6000602082840312156200012857600080fd5b81516001600160a01b03811681146200014057600080fd5b9392505050565b608051611e0a6200017860003960008181610236015281816108fa01528181610d6f0152610e3d0152611e0a6000f3fe608060405234801561001057600080fd5b50600436106101ae5760003560e01c806361b01b5d116100ee578063c4e01fa411610097578063df6fadc111610071578063df6fadc114610386578063e3dae51c146103a1578063f3e73875146103b4578063fabc1cbc146103c757600080fd5b8063c4e01fa41461034d578063ce7c2ac214610360578063d9caed121461037357600080fd5b80638c871019116100c85780638c871019146103125780638f6a624014610325578063ab5921e11461033857600080fd5b806361b01b5d146102dd5780637a8b2637146102e6578063886f1195146102f957600080fd5b80633a98ef391161015b578063553ca5f811610135578063553ca5f81461028b578063595c6a671461029e5780635ac86ab7146102a65780635c975abb146102d557600080fd5b80633a98ef391461025857806343fe08b01461026f57806347e7ef241461027857600080fd5b8063136439dd1161018c578063136439dd146101ee5780632495a5991461020157806339b70e381461023157600080fd5b8063019e2729146101b357806310d67a2f146101c857806311c70c9d146101db575b600080fd5b6101c66101c1366004611ad5565b6103da565b005b6101c66101d6366004611b1f565b61050f565b6101c66101e9366004611b43565b610605565b6101c66101fc366004611b65565b6106fd565b603354610214906001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b6102147f000000000000000000000000000000000000000000000000000000000000000081565b61026160345481565b604051908152602001610228565b61026160665481565b610261610286366004611b7e565b610897565b610261610299366004611b1f565b610a50565b6101c6610a64565b6102c56102b4366004611baa565b6001805460ff9092161b9081161490565b6040519015158152602001610228565b600154610261565b61026160675481565b6102616102f4366004611b65565b610b86565b600054610214906201000090046001600160a01b031681565b610261610320366004611b65565b610bd1565b610261610333366004611b1f565b610bdc565b610340610bea565b6040516102289190611bf1565b6101c661035b366004611c24565b610c0a565b61026161036e366004611b1f565b610d2e565b6101c6610381366004611c5d565b610ddc565b60665460675460408051928352602083019190915201610228565b6102616103af366004611b65565b610fb8565b6102616103c2366004611b65565b610ff1565b6101c66103d5366004611b65565b610ffc565b600054610100900460ff16158080156103fa5750600054600160ff909116105b806104145750303b158015610414575060005460ff166001145b61048b5760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a656400000000000000000000000000000000000060648201526084015b60405180910390fd5b6000805460ff1916600117905580156104ae576000805461ff0019166101001790555b6104b8858561119b565b6104c283836112ba565b8015610508576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b5050505050565b600060029054906101000a90046001600160a01b03166001600160a01b031663eab66d7a6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610562573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105869190611c9e565b6001600160a01b0316336001600160a01b0316146105f95760405162461bcd60e51b815260206004820152602a60248201527f6d73672e73656e646572206973206e6f74207065726d697373696f6e6564206160448201526939903ab73830bab9b2b960b11b6064820152608401610482565b61060281611375565b50565b600060029054906101000a90046001600160a01b03166001600160a01b031663eab66d7a6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610658573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061067c9190611c9e565b6001600160a01b0316336001600160a01b0316146106ef5760405162461bcd60e51b815260206004820152602a60248201527f6d73672e73656e646572206973206e6f74207065726d697373696f6e6564206160448201526939903ab73830bab9b2b960b11b6064820152608401610482565b6106f9828261119b565b5050565b60005460405163237dfb4760e11b8152336004820152620100009091046001600160a01b0316906346fbf68e90602401602060405180830381865afa15801561074a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061076e9190611cbb565b6107e05760405162461bcd60e51b815260206004820152602860248201527f6d73672e73656e646572206973206e6f74207065726d697373696f6e6564206160448201527f73207061757365720000000000000000000000000000000000000000000000006064820152608401610482565b600154818116146108595760405162461bcd60e51b815260206004820152603860248201527f5061757361626c652e70617573653a20696e76616c696420617474656d70742060448201527f746f20756e70617573652066756e6374696f6e616c69747900000000000000006064820152608401610482565b600181905560405181815233907fab40a374bc51de372200a8bc981af8c9ecdc08dfdaef0bb6e09f88f3c616ef3d906020015b60405180910390a250565b6001805460009182918116036108ef5760405162461bcd60e51b815260206004820152601960248201527f5061757361626c653a20696e64657820697320706175736564000000000000006044820152606401610482565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146109675760405162461bcd60e51b815260206004820181905260248201527f5374726174656779426173652e6f6e6c7953747261746567794d616e616765726044820152606401610482565b61097184846114a4565b60345460006109826103e883611cf3565b905060006103e86109916115a5565b61099b9190611cf3565b905060006109a98783611d06565b9050806109b68489611d19565b6109c09190611d30565b955085600003610a385760405162461bcd60e51b815260206004820152602e60248201527f5374726174656779426173652e6465706f7369743a206e65775368617265732060448201527f63616e6e6f74206265207a65726f0000000000000000000000000000000000006064820152608401610482565b610a428685611cf3565b603455505050505092915050565b6000610a5e6102f483610d2e565b92915050565b60005460405163237dfb4760e11b8152336004820152620100009091046001600160a01b0316906346fbf68e90602401602060405180830381865afa158015610ab1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ad59190611cbb565b610b475760405162461bcd60e51b815260206004820152602860248201527f6d73672e73656e646572206973206e6f74207065726d697373696f6e6564206160448201527f73207061757365720000000000000000000000000000000000000000000000006064820152608401610482565b600019600181905560405190815233907fab40a374bc51de372200a8bc981af8c9ecdc08dfdaef0bb6e09f88f3c616ef3d9060200160405180910390a2565b6000806103e8603454610b999190611cf3565b905060006103e8610ba86115a5565b610bb29190611cf3565b905081610bbf8583611d19565b610bc99190611d30565b949350505050565b6000610a5e82610fb8565b6000610a5e6103c283610d2e565b60606040518060800160405280604d8152602001611d88604d9139905090565b600054610100900460ff1615808015610c2a5750600054600160ff909116105b80610c445750303b158015610c44575060005460ff166001145b610cb65760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a65640000000000000000000000000000000000006064820152608401610482565b6000805460ff191660011790558015610cd9576000805461ff0019166101001790555b610ce383836112ba565b8015610d29576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b505050565b6040517f7a7e0d920000000000000000000000000000000000000000000000000000000081526001600160a01b0382811660048301523060248301526000917f000000000000000000000000000000000000000000000000000000000000000090911690637a7e0d9290604401602060405180830381865afa158015610db8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a5e9190611d52565b60018054600290811603610e325760405162461bcd60e51b815260206004820152601960248201527f5061757361626c653a20696e64657820697320706175736564000000000000006044820152606401610482565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610eaa5760405162461bcd60e51b815260206004820181905260248201527f5374726174656779426173652e6f6e6c7953747261746567794d616e616765726044820152606401610482565b610eb5848484611630565b60345480831115610f545760405162461bcd60e51b815260206004820152604d60248201527f5374726174656779426173652e77697468647261773a20616d6f756e7453686160448201527f726573206d757374206265206c657373207468616e206f7220657175616c207460648201527f6f20746f74616c53686172657300000000000000000000000000000000000000608482015260a401610482565b6000610f626103e883611cf3565b905060006103e8610f716115a5565b610f7b9190611cf3565b9050600082610f8a8784611d19565b610f949190611d30565b9050610fa08685611d06565b603455610fae8888836116b3565b5050505050505050565b6000806103e8603454610fcb9190611cf3565b905060006103e8610fda6115a5565b610fe49190611cf3565b905080610bbf8386611d19565b6000610a5e82610b86565b600060029054906101000a90046001600160a01b03166001600160a01b031663eab66d7a6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561104f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110739190611c9e565b6001600160a01b0316336001600160a01b0316146110e65760405162461bcd60e51b815260206004820152602a60248201527f6d73672e73656e646572206973206e6f74207065726d697373696f6e6564206160448201526939903ab73830bab9b2b960b11b6064820152608401610482565b6001541981196001541916146111645760405162461bcd60e51b815260206004820152603860248201527f5061757361626c652e756e70617573653a20696e76616c696420617474656d7060448201527f7420746f2070617573652066756e6374696f6e616c69747900000000000000006064820152608401610482565b600181905560405181815233907f3582d1828e26bf56bd801502bc021ac0bc8afb57c826e4986b45593c8fad389c9060200161088c565b60665460408051918252602082018490527ff97ed4e083acac67830025ecbc756d8fe847cdbdca4cee3fe1e128e98b54ecb5910160405180910390a160675460408051918252602082018390527f6ab181e0440bfbf4bacdf2e99674735ce6638005490688c5f994f5399353e452910160405180910390a1808211156112af5760405162461bcd60e51b815260206004820152604b60248201527f53747261746567794261736554564c4c696d6974732e5f73657454564c4c696d60448201527f6974733a206d61785065724465706f7369742065786365656473206d6178546f60648201527f74616c4465706f73697473000000000000000000000000000000000000000000608482015260a401610482565b606691909155606755565b600054610100900460ff166113375760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e670000000000000000000000000000000000000000006064820152608401610482565b603380547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384161790556106f98160006116c7565b6001600160a01b0381166114175760405162461bcd60e51b815260206004820152604960248201527f5061757361626c652e5f73657450617573657252656769737472793a206e657760448201527f50617573657252656769737472792063616e6e6f7420626520746865207a657260648201527f6f20616464726573730000000000000000000000000000000000000000000000608482015260a401610482565b600054604080516001600160a01b03620100009093048316815291831660208301527f6e9fcd539896fca60e8b0f01dd580233e48a6b0f7df013b89ba7f565869acdb6910160405180910390a1600080546001600160a01b0390921662010000027fffffffffffffffffffff0000000000000000000000000000000000000000ffff909216919091179055565b60665481111561151c5760405162461bcd60e51b815260206004820152602f60248201527f53747261746567794261736554564c4c696d6974733a206d617820706572206460448201527f65706f73697420657863656564656400000000000000000000000000000000006064820152608401610482565b6067546115276115a5565b111561159b5760405162461bcd60e51b815260206004820152602c60248201527f53747261746567794261736554564c4c696d6974733a206d6178206465706f7360448201527f69747320657863656564656400000000000000000000000000000000000000006064820152608401610482565b6106f982826117c9565b6033546040517f70a082310000000000000000000000000000000000000000000000000000000081523060048201526000916001600160a01b0316906370a0823190602401602060405180830381865afa158015611607573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061162b9190611d52565b905090565b6033546001600160a01b03838116911614610d295760405162461bcd60e51b815260206004820152603b60248201527f5374726174656779426173652e77697468647261773a2043616e206f6e6c792060448201527f77697468647261772074686520737472617465677920746f6b656e00000000006064820152608401610482565b610d296001600160a01b038316848361184c565b6000546201000090046001600160a01b03161580156116ee57506001600160a01b03821615155b6117865760405162461bcd60e51b815260206004820152604760248201527f5061757361626c652e5f696e697469616c697a655061757365723a205f696e6960448201527f7469616c697a6550617573657228292063616e206f6e6c792062652063616c6c60648201527f6564206f6e636500000000000000000000000000000000000000000000000000608482015260a401610482565b600181905560405181815233907fab40a374bc51de372200a8bc981af8c9ecdc08dfdaef0bb6e09f88f3c616ef3d9060200160405180910390a26106f982611375565b6033546001600160a01b038381169116146106f95760405162461bcd60e51b815260206004820152603660248201527f5374726174656779426173652e6465706f7369743a2043616e206f6e6c79206460448201527f65706f73697420756e6465726c79696e67546f6b656e000000000000000000006064820152608401610482565b604080516001600160a01b03848116602483015260448083018590528351808403909101815260649092018352602080830180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fa9059cbb0000000000000000000000000000000000000000000000000000000017905283518085019094528084527f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c656490840152610d299286929160009161190a91851690849061199d565b905080516000148061192b57508080602001905181019061192b9190611cbb565b610d295760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f742073756363656564000000000000000000000000000000000000000000006064820152608401610482565b6060610bc9848460008585600080866001600160a01b031685876040516119c49190611d6b565b60006040518083038185875af1925050503d8060008114611a01576040519150601f19603f3d011682016040523d82523d6000602084013e611a06565b606091505b5091509150611a1787838387611a22565b979650505050505050565b60608315611a91578251600003611a8a576001600160a01b0385163b611a8a5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610482565b5081610bc9565b610bc98383815115611aa65781518083602001fd5b8060405162461bcd60e51b81526004016104829190611bf1565b6001600160a01b038116811461060257600080fd5b60008060008060808587031215611aeb57600080fd5b84359350602085013592506040850135611b0481611ac0565b91506060850135611b1481611ac0565b939692955090935050565b600060208284031215611b3157600080fd5b8135611b3c81611ac0565b9392505050565b60008060408385031215611b5657600080fd5b50508035926020909101359150565b600060208284031215611b7757600080fd5b5035919050565b60008060408385031215611b9157600080fd5b8235611b9c81611ac0565b946020939093013593505050565b600060208284031215611bbc57600080fd5b813560ff81168114611b3c57600080fd5b60005b83811015611be8578181015183820152602001611bd0565b50506000910152565b6020815260008251806020840152611c10816040850160208701611bcd565b601f01601f19169190910160400192915050565b60008060408385031215611c3757600080fd5b8235611c4281611ac0565b91506020830135611c5281611ac0565b809150509250929050565b600080600060608486031215611c7257600080fd5b8335611c7d81611ac0565b92506020840135611c8d81611ac0565b929592945050506040919091013590565b600060208284031215611cb057600080fd5b8151611b3c81611ac0565b600060208284031215611ccd57600080fd5b81518015158114611b3c57600080fd5b634e487b7160e01b600052601160045260246000fd5b80820180821115610a5e57610a5e611cdd565b81810381811115610a5e57610a5e611cdd565b8082028115828204841417610a5e57610a5e611cdd565b600082611d4d57634e487b7160e01b600052601260045260246000fd5b500490565b600060208284031215611d6457600080fd5b5051919050565b60008251611d7d818460208701611bcd565b919091019291505056fe4261736520537472617465677920696d706c656d656e746174696f6e20746f20696e68657269742066726f6d20666f72206d6f726520636f6d706c657820696d706c656d656e746174696f6e73a26469706673582212202c33436acb611987f4751218a55f67c48bfa32b1ab9cd5f54cd40b7d29df031364736f6c63430008140033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101ae5760003560e01c806361b01b5d116100ee578063c4e01fa411610097578063df6fadc111610071578063df6fadc114610386578063e3dae51c146103a1578063f3e73875146103b4578063fabc1cbc146103c757600080fd5b8063c4e01fa41461034d578063ce7c2ac214610360578063d9caed121461037357600080fd5b80638c871019116100c85780638c871019146103125780638f6a624014610325578063ab5921e11461033857600080fd5b806361b01b5d146102dd5780637a8b2637146102e6578063886f1195146102f957600080fd5b80633a98ef391161015b578063553ca5f811610135578063553ca5f81461028b578063595c6a671461029e5780635ac86ab7146102a65780635c975abb146102d557600080fd5b80633a98ef391461025857806343fe08b01461026f57806347e7ef241461027857600080fd5b8063136439dd1161018c578063136439dd146101ee5780632495a5991461020157806339b70e381461023157600080fd5b8063019e2729146101b357806310d67a2f146101c857806311c70c9d146101db575b600080fd5b6101c66101c1366004611ad5565b6103da565b005b6101c66101d6366004611b1f565b61050f565b6101c66101e9366004611b43565b610605565b6101c66101fc366004611b65565b6106fd565b603354610214906001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b6102147f000000000000000000000000000000000000000000000000000000000000000081565b61026160345481565b604051908152602001610228565b61026160665481565b610261610286366004611b7e565b610897565b610261610299366004611b1f565b610a50565b6101c6610a64565b6102c56102b4366004611baa565b6001805460ff9092161b9081161490565b6040519015158152602001610228565b600154610261565b61026160675481565b6102616102f4366004611b65565b610b86565b600054610214906201000090046001600160a01b031681565b610261610320366004611b65565b610bd1565b610261610333366004611b1f565b610bdc565b610340610bea565b6040516102289190611bf1565b6101c661035b366004611c24565b610c0a565b61026161036e366004611b1f565b610d2e565b6101c6610381366004611c5d565b610ddc565b60665460675460408051928352602083019190915201610228565b6102616103af366004611b65565b610fb8565b6102616103c2366004611b65565b610ff1565b6101c66103d5366004611b65565b610ffc565b600054610100900460ff16158080156103fa5750600054600160ff909116105b806104145750303b158015610414575060005460ff166001145b61048b5760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a656400000000000000000000000000000000000060648201526084015b60405180910390fd5b6000805460ff1916600117905580156104ae576000805461ff0019166101001790555b6104b8858561119b565b6104c283836112ba565b8015610508576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b5050505050565b600060029054906101000a90046001600160a01b03166001600160a01b031663eab66d7a6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610562573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105869190611c9e565b6001600160a01b0316336001600160a01b0316146105f95760405162461bcd60e51b815260206004820152602a60248201527f6d73672e73656e646572206973206e6f74207065726d697373696f6e6564206160448201526939903ab73830bab9b2b960b11b6064820152608401610482565b61060281611375565b50565b600060029054906101000a90046001600160a01b03166001600160a01b031663eab66d7a6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610658573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061067c9190611c9e565b6001600160a01b0316336001600160a01b0316146106ef5760405162461bcd60e51b815260206004820152602a60248201527f6d73672e73656e646572206973206e6f74207065726d697373696f6e6564206160448201526939903ab73830bab9b2b960b11b6064820152608401610482565b6106f9828261119b565b5050565b60005460405163237dfb4760e11b8152336004820152620100009091046001600160a01b0316906346fbf68e90602401602060405180830381865afa15801561074a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061076e9190611cbb565b6107e05760405162461bcd60e51b815260206004820152602860248201527f6d73672e73656e646572206973206e6f74207065726d697373696f6e6564206160448201527f73207061757365720000000000000000000000000000000000000000000000006064820152608401610482565b600154818116146108595760405162461bcd60e51b815260206004820152603860248201527f5061757361626c652e70617573653a20696e76616c696420617474656d70742060448201527f746f20756e70617573652066756e6374696f6e616c69747900000000000000006064820152608401610482565b600181905560405181815233907fab40a374bc51de372200a8bc981af8c9ecdc08dfdaef0bb6e09f88f3c616ef3d906020015b60405180910390a250565b6001805460009182918116036108ef5760405162461bcd60e51b815260206004820152601960248201527f5061757361626c653a20696e64657820697320706175736564000000000000006044820152606401610482565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146109675760405162461bcd60e51b815260206004820181905260248201527f5374726174656779426173652e6f6e6c7953747261746567794d616e616765726044820152606401610482565b61097184846114a4565b60345460006109826103e883611cf3565b905060006103e86109916115a5565b61099b9190611cf3565b905060006109a98783611d06565b9050806109b68489611d19565b6109c09190611d30565b955085600003610a385760405162461bcd60e51b815260206004820152602e60248201527f5374726174656779426173652e6465706f7369743a206e65775368617265732060448201527f63616e6e6f74206265207a65726f0000000000000000000000000000000000006064820152608401610482565b610a428685611cf3565b603455505050505092915050565b6000610a5e6102f483610d2e565b92915050565b60005460405163237dfb4760e11b8152336004820152620100009091046001600160a01b0316906346fbf68e90602401602060405180830381865afa158015610ab1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ad59190611cbb565b610b475760405162461bcd60e51b815260206004820152602860248201527f6d73672e73656e646572206973206e6f74207065726d697373696f6e6564206160448201527f73207061757365720000000000000000000000000000000000000000000000006064820152608401610482565b600019600181905560405190815233907fab40a374bc51de372200a8bc981af8c9ecdc08dfdaef0bb6e09f88f3c616ef3d9060200160405180910390a2565b6000806103e8603454610b999190611cf3565b905060006103e8610ba86115a5565b610bb29190611cf3565b905081610bbf8583611d19565b610bc99190611d30565b949350505050565b6000610a5e82610fb8565b6000610a5e6103c283610d2e565b60606040518060800160405280604d8152602001611d88604d9139905090565b600054610100900460ff1615808015610c2a5750600054600160ff909116105b80610c445750303b158015610c44575060005460ff166001145b610cb65760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a65640000000000000000000000000000000000006064820152608401610482565b6000805460ff191660011790558015610cd9576000805461ff0019166101001790555b610ce383836112ba565b8015610d29576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b505050565b6040517f7a7e0d920000000000000000000000000000000000000000000000000000000081526001600160a01b0382811660048301523060248301526000917f000000000000000000000000000000000000000000000000000000000000000090911690637a7e0d9290604401602060405180830381865afa158015610db8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a5e9190611d52565b60018054600290811603610e325760405162461bcd60e51b815260206004820152601960248201527f5061757361626c653a20696e64657820697320706175736564000000000000006044820152606401610482565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610eaa5760405162461bcd60e51b815260206004820181905260248201527f5374726174656779426173652e6f6e6c7953747261746567794d616e616765726044820152606401610482565b610eb5848484611630565b60345480831115610f545760405162461bcd60e51b815260206004820152604d60248201527f5374726174656779426173652e77697468647261773a20616d6f756e7453686160448201527f726573206d757374206265206c657373207468616e206f7220657175616c207460648201527f6f20746f74616c53686172657300000000000000000000000000000000000000608482015260a401610482565b6000610f626103e883611cf3565b905060006103e8610f716115a5565b610f7b9190611cf3565b9050600082610f8a8784611d19565b610f949190611d30565b9050610fa08685611d06565b603455610fae8888836116b3565b5050505050505050565b6000806103e8603454610fcb9190611cf3565b905060006103e8610fda6115a5565b610fe49190611cf3565b905080610bbf8386611d19565b6000610a5e82610b86565b600060029054906101000a90046001600160a01b03166001600160a01b031663eab66d7a6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561104f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110739190611c9e565b6001600160a01b0316336001600160a01b0316146110e65760405162461bcd60e51b815260206004820152602a60248201527f6d73672e73656e646572206973206e6f74207065726d697373696f6e6564206160448201526939903ab73830bab9b2b960b11b6064820152608401610482565b6001541981196001541916146111645760405162461bcd60e51b815260206004820152603860248201527f5061757361626c652e756e70617573653a20696e76616c696420617474656d7060448201527f7420746f2070617573652066756e6374696f6e616c69747900000000000000006064820152608401610482565b600181905560405181815233907f3582d1828e26bf56bd801502bc021ac0bc8afb57c826e4986b45593c8fad389c9060200161088c565b60665460408051918252602082018490527ff97ed4e083acac67830025ecbc756d8fe847cdbdca4cee3fe1e128e98b54ecb5910160405180910390a160675460408051918252602082018390527f6ab181e0440bfbf4bacdf2e99674735ce6638005490688c5f994f5399353e452910160405180910390a1808211156112af5760405162461bcd60e51b815260206004820152604b60248201527f53747261746567794261736554564c4c696d6974732e5f73657454564c4c696d60448201527f6974733a206d61785065724465706f7369742065786365656473206d6178546f60648201527f74616c4465706f73697473000000000000000000000000000000000000000000608482015260a401610482565b606691909155606755565b600054610100900460ff166113375760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e670000000000000000000000000000000000000000006064820152608401610482565b603380547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384161790556106f98160006116c7565b6001600160a01b0381166114175760405162461bcd60e51b815260206004820152604960248201527f5061757361626c652e5f73657450617573657252656769737472793a206e657760448201527f50617573657252656769737472792063616e6e6f7420626520746865207a657260648201527f6f20616464726573730000000000000000000000000000000000000000000000608482015260a401610482565b600054604080516001600160a01b03620100009093048316815291831660208301527f6e9fcd539896fca60e8b0f01dd580233e48a6b0f7df013b89ba7f565869acdb6910160405180910390a1600080546001600160a01b0390921662010000027fffffffffffffffffffff0000000000000000000000000000000000000000ffff909216919091179055565b60665481111561151c5760405162461bcd60e51b815260206004820152602f60248201527f53747261746567794261736554564c4c696d6974733a206d617820706572206460448201527f65706f73697420657863656564656400000000000000000000000000000000006064820152608401610482565b6067546115276115a5565b111561159b5760405162461bcd60e51b815260206004820152602c60248201527f53747261746567794261736554564c4c696d6974733a206d6178206465706f7360448201527f69747320657863656564656400000000000000000000000000000000000000006064820152608401610482565b6106f982826117c9565b6033546040517f70a082310000000000000000000000000000000000000000000000000000000081523060048201526000916001600160a01b0316906370a0823190602401602060405180830381865afa158015611607573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061162b9190611d52565b905090565b6033546001600160a01b03838116911614610d295760405162461bcd60e51b815260206004820152603b60248201527f5374726174656779426173652e77697468647261773a2043616e206f6e6c792060448201527f77697468647261772074686520737472617465677920746f6b656e00000000006064820152608401610482565b610d296001600160a01b038316848361184c565b6000546201000090046001600160a01b03161580156116ee57506001600160a01b03821615155b6117865760405162461bcd60e51b815260206004820152604760248201527f5061757361626c652e5f696e697469616c697a655061757365723a205f696e6960448201527f7469616c697a6550617573657228292063616e206f6e6c792062652063616c6c60648201527f6564206f6e636500000000000000000000000000000000000000000000000000608482015260a401610482565b600181905560405181815233907fab40a374bc51de372200a8bc981af8c9ecdc08dfdaef0bb6e09f88f3c616ef3d9060200160405180910390a26106f982611375565b6033546001600160a01b038381169116146106f95760405162461bcd60e51b815260206004820152603660248201527f5374726174656779426173652e6465706f7369743a2043616e206f6e6c79206460448201527f65706f73697420756e6465726c79696e67546f6b656e000000000000000000006064820152608401610482565b604080516001600160a01b03848116602483015260448083018590528351808403909101815260649092018352602080830180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fa9059cbb0000000000000000000000000000000000000000000000000000000017905283518085019094528084527f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c656490840152610d299286929160009161190a91851690849061199d565b905080516000148061192b57508080602001905181019061192b9190611cbb565b610d295760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f742073756363656564000000000000000000000000000000000000000000006064820152608401610482565b6060610bc9848460008585600080866001600160a01b031685876040516119c49190611d6b565b60006040518083038185875af1925050503d8060008114611a01576040519150601f19603f3d011682016040523d82523d6000602084013e611a06565b606091505b5091509150611a1787838387611a22565b979650505050505050565b60608315611a91578251600003611a8a576001600160a01b0385163b611a8a5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610482565b5081610bc9565b610bc98383815115611aa65781518083602001fd5b8060405162461bcd60e51b81526004016104829190611bf1565b6001600160a01b038116811461060257600080fd5b60008060008060808587031215611aeb57600080fd5b84359350602085013592506040850135611b0481611ac0565b91506060850135611b1481611ac0565b939692955090935050565b600060208284031215611b3157600080fd5b8135611b3c81611ac0565b9392505050565b60008060408385031215611b5657600080fd5b50508035926020909101359150565b600060208284031215611b7757600080fd5b5035919050565b60008060408385031215611b9157600080fd5b8235611b9c81611ac0565b946020939093013593505050565b600060208284031215611bbc57600080fd5b813560ff81168114611b3c57600080fd5b60005b83811015611be8578181015183820152602001611bd0565b50506000910152565b6020815260008251806020840152611c10816040850160208701611bcd565b601f01601f19169190910160400192915050565b60008060408385031215611c3757600080fd5b8235611c4281611ac0565b91506020830135611c5281611ac0565b809150509250929050565b600080600060608486031215611c7257600080fd5b8335611c7d81611ac0565b92506020840135611c8d81611ac0565b929592945050506040919091013590565b600060208284031215611cb057600080fd5b8151611b3c81611ac0565b600060208284031215611ccd57600080fd5b81518015158114611b3c57600080fd5b634e487b7160e01b600052601160045260246000fd5b80820180821115610a5e57610a5e611cdd565b81810381811115610a5e57610a5e611cdd565b8082028115828204841417610a5e57610a5e611cdd565b600082611d4d57634e487b7160e01b600052601260045260246000fd5b500490565b600060208284031215611d6457600080fd5b5051919050565b60008251611d7d818460208701611bcd565b919091019291505056fe4261736520537472617465677920696d706c656d656e746174696f6e20746f20696e68657269742066726f6d20666f72206d6f726520636f6d706c657820696d706c656d656e746174696f6e73a26469706673582212202c33436acb611987f4751218a55f67c48bfa32b1ab9cd5f54cd40b7d29df031364736f6c63430008140033",
  "devdoc": {
    "details": "Note that this implementation still converts between any amount of shares or underlying tokens in its view functions; these functions purposefully do not take the TVL limit into account.",
    "events": {
      "Initialized(uint8)": {
        "details": "Triggered when the contract has been initialized or reinitialized."
      }
    },
    "kind": "dev",
    "methods": {
      "constructor": {
        "custom:oz-upgrades-unsafe-allow": "constructor"
      },
      "deposit(address,uint256)": {
        "details": "This function is only callable by the strategyManager contract. It is invoked inside of the strategyManager's `depositIntoStrategy` function, and individual share balances are recorded in the strategyManager as well.Note that the assumption is made that `amount` of `token` has already been transferred directly to this contract (as performed in the StrategyManager's deposit functions). In particular, setting the `underlyingToken` of this contract to be a fee-on-transfer token will break the assumption that the amount this contract *received* of the token is equal to the amount that was input when the transfer was performed (i.e. the amount transferred 'out' of the depositor's balance).Note that any validation of `token` is done inside `_beforeDeposit`. This can be overridden if needed.",
        "params": {
          "amount": "is the amount of token being deposited",
          "token": "is the ERC20 token being deposited"
        },
        "returns": {
          "newShares": "is the number of new shares issued at the current exchange ratio."
        }
      },
      "pause(uint256)": {
        "details": "This function can only pause functionality, and thus cannot 'unflip' any bit in `_paused` from 1 to 0.",
        "params": {
          "newPausedStatus": "represents the new value for `_paused` to take, which means it may flip several bits at once."
        }
      },
      "setTVLLimits(uint256,uint256)": {
        "details": "Callable only by the unpauser of this contractWe note that there is a potential race condition between a call to this function that lowers either or both of these limits and call(s) to `deposit`, that may result in some calls to `deposit` reverting.",
        "params": {
          "newMaxTotalDeposits": "The new maximum deposits"
        }
      },
      "sharesToUnderlying(uint256)": {
        "details": "Implementation for these functions in particular may vary significantly for different strategies",
        "params": {
          "amountShares": "is the amount of shares to calculate its conversion into the underlying token"
        },
        "returns": {
          "_0": "The amount of underlying tokens corresponding to the input `amountShares`"
        }
      },
      "sharesToUnderlyingView(uint256)": {
        "details": "Implementation for these functions in particular may vary significantly for different strategies",
        "params": {
          "amountShares": "is the amount of shares to calculate its conversion into the underlying token"
        },
        "returns": {
          "_0": "The amount of underlying tokens corresponding to the input `amountShares`"
        }
      },
      "underlyingToShares(uint256)": {
        "details": "Implementation for these functions in particular may vary significantly for different strategies",
        "params": {
          "amountUnderlying": "is the amount of `underlyingToken` to calculate its conversion into strategy shares"
        },
        "returns": {
          "_0": "The amount of shares corresponding to the input `amountUnderlying`"
        }
      },
      "underlyingToSharesView(uint256)": {
        "details": "Implementation for these functions in particular may vary significantly for different strategies",
        "params": {
          "amountUnderlying": "is the amount of `underlyingToken` to calculate its conversion into strategy shares"
        },
        "returns": {
          "_0": "The amount of shares corresponding to the input `amountUnderlying`"
        }
      },
      "unpause(uint256)": {
        "details": "This function can only unpause functionality, and thus cannot 'flip' any bit in `_paused` from 0 to 1.",
        "params": {
          "newPausedStatus": "represents the new value for `_paused` to take, which means it may flip several bits at once."
        }
      },
      "withdraw(address,address,uint256)": {
        "details": "This function is only callable by the strategyManager contract. It is invoked inside of the strategyManager's other functions, and individual share balances are recorded in the strategyManager as well.Note that any validation of `token` is done inside `_beforeWithdrawal`. This can be overridden if needed.",
        "params": {
          "amountShares": "is the amount of shares being withdrawn",
          "recipient": "is the address to receive the withdrawn funds",
          "token": "is the ERC20 token being transferred out"
        }
      }
    },
    "stateVariables": {
      "__gap": {
        "details": "This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain. See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps"
      }
    },
    "title": "A Strategy implementation inheriting from `StrategyBase` that limits the total amount of deposits it will accept.",
    "version": 1
  },
  "userdoc": {
    "events": {
      "MaxPerDepositUpdated(uint256,uint256)": {
        "notice": "Emitted when `maxPerDeposit` value is updated from `previousValue` to `newValue`"
      },
      "MaxTotalDepositsUpdated(uint256,uint256)": {
        "notice": "Emitted when `maxTotalDeposits` value is updated from `previousValue` to `newValue`"
      },
      "Paused(address,uint256)": {
        "notice": "Emitted when the pause is triggered by `account`, and changed to `newPausedStatus`."
      },
      "PauserRegistrySet(address,address)": {
        "notice": "Emitted when the `pauserRegistry` is set to `newPauserRegistry`."
      },
      "Unpaused(address,uint256)": {
        "notice": "Emitted when the pause is lifted by `account`, and changed to `newPausedStatus`."
      }
    },
    "kind": "user",
    "methods": {
      "constructor": {
        "notice": "solhint-disable-next-line no-empty-blocks"
      },
      "deposit(address,uint256)": {
        "notice": "Used to deposit tokens into this Strategy"
      },
      "explanation()": {
        "notice": "Currently returns a brief string explaining the strategy's goal & purpose, but for more complex strategies, may be a link to metadata that explains in more detail."
      },
      "getTVLLimits()": {
        "notice": "Simple getter function that returns the current values of `maxPerDeposit` and `maxTotalDeposits`."
      },
      "maxPerDeposit()": {
        "notice": "The maximum deposit (in underlyingToken) that this strategy will accept per deposit"
      },
      "maxTotalDeposits()": {
        "notice": "The maximum deposits (in underlyingToken) that this strategy will hold"
      },
      "pause(uint256)": {
        "notice": "This function is used to pause an BinLayer contract's functionality. It is permissioned to the `pauser` address, which is expected to be a low threshold multisig."
      },
      "pauseAll()": {
        "notice": "Alias for `pause(type(uint256).max)`."
      },
      "paused()": {
        "notice": "Returns the current paused status as a uint256."
      },
      "paused(uint8)": {
        "notice": "Returns 'true' if the `indexed`th bit of `_paused` is 1, and 'false' otherwise"
      },
      "pauserRegistry()": {
        "notice": "Address of the `PauserRegistry` contract that this contract defers to for determining access control (for pausing)."
      },
      "setPauserRegistry(address)": {
        "notice": "Allows the unpauser to set a new pauser registry"
      },
      "setTVLLimits(uint256,uint256)": {
        "notice": "Sets the maximum deposits (in underlyingToken) that this strategy will hold and accept per deposit"
      },
      "shares(address)": {
        "notice": "convenience function for fetching the current total shares of `user` in this strategy, by querying the `strategyManager` contract"
      },
      "sharesToUnderlying(uint256)": {
        "notice": "Used to convert a number of shares to the equivalent amount of underlying tokens for this strategy.In contrast to `sharesToUnderlyingView`, this function **may** make state modifications"
      },
      "sharesToUnderlyingView(uint256)": {
        "notice": "Used to convert a number of shares to the equivalent amount of underlying tokens for this strategy.In contrast to `sharesToUnderlying`, this function guarantees no state modifications"
      },
      "strategyManager()": {
        "notice": "BinLayer's StrategyManager contract"
      },
      "totalShares()": {
        "notice": "The total number of extant shares in this Strategy"
      },
      "underlyingToShares(uint256)": {
        "notice": "Used to convert an amount of underlying tokens to the equivalent amount of shares in this strategy.In contrast to `underlyingToSharesView`, this function **may** make state modifications"
      },
      "underlyingToSharesView(uint256)": {
        "notice": "Used to convert an amount of underlying tokens to the equivalent amount of shares in this strategy.In contrast to `underlyingToShares`, this function guarantees no state modifications"
      },
      "underlyingToken()": {
        "notice": "The underlying token for shares in this Strategy"
      },
      "unpause(uint256)": {
        "notice": "This function is used to unpause an BinLayer contract's functionality. It is permissioned to the `unpauser` address, which is expected to be a high threshold multisig or governance contract."
      },
      "userUnderlying(address)": {
        "notice": "convenience function for fetching the current underlying value of all of the `user`'s shares in this strategy. In contrast to `userUnderlyingView`, this function **may** make state modifications"
      },
      "userUnderlyingView(address)": {
        "notice": "convenience function for fetching the current underlying value of all of the `user`'s shares in this strategy. In contrast to `userUnderlying`, this function guarantees no state modifications"
      },
      "withdraw(address,address,uint256)": {
        "notice": "Used to withdraw tokens from this Strategy, to the `recipient`'s address"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 139,
        "contract": "contracts/strategies/StrategyBaseTVLLimits.sol:StrategyBaseTVLLimits",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_uint8"
      },
      {
        "astId": 142,
        "contract": "contracts/strategies/StrategyBaseTVLLimits.sol:StrategyBaseTVLLimits",
        "label": "_initializing",
        "offset": 1,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 10308,
        "contract": "contracts/strategies/StrategyBaseTVLLimits.sol:StrategyBaseTVLLimits",
        "label": "pauserRegistry",
        "offset": 2,
        "slot": "0",
        "type": "t_contract(IPauserRegistry)7893"
      },
      {
        "astId": 10311,
        "contract": "contracts/strategies/StrategyBaseTVLLimits.sol:StrategyBaseTVLLimits",
        "label": "_paused",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 10593,
        "contract": "contracts/strategies/StrategyBaseTVLLimits.sol:StrategyBaseTVLLimits",
        "label": "__gap",
        "offset": 0,
        "slot": "2",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 10777,
        "contract": "contracts/strategies/StrategyBaseTVLLimits.sol:StrategyBaseTVLLimits",
        "label": "underlyingToken",
        "offset": 0,
        "slot": "51",
        "type": "t_contract(IERC20)1559"
      },
      {
        "astId": 10780,
        "contract": "contracts/strategies/StrategyBaseTVLLimits.sol:StrategyBaseTVLLimits",
        "label": "totalShares",
        "offset": 0,
        "slot": "52",
        "type": "t_uint256"
      },
      {
        "astId": 11212,
        "contract": "contracts/strategies/StrategyBaseTVLLimits.sol:StrategyBaseTVLLimits",
        "label": "__gap",
        "offset": 0,
        "slot": "53",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 11222,
        "contract": "contracts/strategies/StrategyBaseTVLLimits.sol:StrategyBaseTVLLimits",
        "label": "maxPerDeposit",
        "offset": 0,
        "slot": "102",
        "type": "t_uint256"
      },
      {
        "astId": 11225,
        "contract": "contracts/strategies/StrategyBaseTVLLimits.sol:StrategyBaseTVLLimits",
        "label": "maxTotalDeposits",
        "offset": 0,
        "slot": "103",
        "type": "t_uint256"
      },
      {
        "astId": 11377,
        "contract": "contracts/strategies/StrategyBaseTVLLimits.sol:StrategyBaseTVLLimits",
        "label": "__gap",
        "offset": 0,
        "slot": "104",
        "type": "t_array(t_uint256)49_storage"
      }
    ],
    "types": {
      "t_array(t_uint256)49_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[49]",
        "numberOfBytes": "1568"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_contract(IERC20)1559": {
        "encoding": "inplace",
        "label": "contract IERC20",
        "numberOfBytes": "20"
      },
      "t_contract(IPauserRegistry)7893": {
        "encoding": "inplace",
        "label": "contract IPauserRegistry",
        "numberOfBytes": "20"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}